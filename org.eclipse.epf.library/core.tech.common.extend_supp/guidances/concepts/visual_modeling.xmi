<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmlns:rmc="http://www.ibm.com/rmc" rmc:version="7.5.1" xmi:id="_SB1n8MM1EdmSIPI87WLu3g" name="visual_modeling,_0XY6UMlgEdmt3adZL5Dmdw" guid="_SB1n8MM1EdmSIPI87WLu3g" changeDate="2008-02-14T04:58:00.000-0800" version="1.0.0">
  <mainDescription>&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;229&quot; alt=&quot;visual modeling&quot; src=&quot;resources/visual.gif&quot; width=&quot;447&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Visual modeling raises the level of abstraction&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Visual modeling is the use of semantically rich, graphical and textual design notations to capture software designs. A&#xD;
    notation, such as UML, allows the level of abstraction to be raised, while maintaining rigorous syntax and semantics.&#xD;
    In this way, it improves communication in the design team, as the design is formed and reviewed, allowing the reader to&#xD;
    reason about the design, and it provides an unambiguous basis for implementation.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    How visual models help&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A model is a simplified view of a system. It shows the essentials of the system from a particular perspective and hides&#xD;
    the nonessential details. Visual models help you:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Increase understanding of complex systems&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Explore and compare design alternatives at a low cost&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Form a foundation for implementation&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Capture requirements precisely&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Communicate decisions unambiguously&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Increase understanding of complex systems&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The importance of models increases as systems become more complex. For example, you can build a doghouse without&#xD;
    blueprints. However, as you progress to building houses and then to skyscrapers, your need for blueprints becomes&#xD;
    pronounced.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Similarly, a small application built by one person in a few days may be easily understood in its entirety. However, an&#xD;
    e&amp;nbsp;-&amp;nbsp;commerce system with tens of thousands of source lines of code (SLOCs) or an air traffic control system&#xD;
    with hundreds of thousands of SLOCs can no longer be easily understood by one person. Constructing models allows a&#xD;
    developer to focus on the big picture, understand how components interact, and identify fatal flaws.&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Among the various types of models are these examples:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Use cases to specify behavior unambiguously&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Class diagrams and data model diagrams to capture design&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        State transition diagrams to model dynamic behavior&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Modeling is important because it helps the team visualize, construct, and document the structure and behavior of the&#xD;
    system without getting lost in complexity.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Explore and compare design alternatives at a low cost&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    You can create and modify simple models inexpensively to explore design alternatives. Innovative ideas can be captured&#xD;
    and reviewed by other developers before investing in costly code development. When coupled with iterative development,&#xD;
    visual modeling helps developers assess design changes and communicate these changes to the entire development team.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Form a foundation for implementation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Today, many projects employ object-oriented programming languages to build reusable, change-tolerant, and stable&#xD;
    systems. To get these benefits, it is even more important to use object technology in design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The creation of visual models, whether&amp;nbsp;on paper; around a whiteboard; or in a modeling tool,&amp;nbsp;can help a team&#xD;
    to gain agreement on key aspects of the system before investing time&amp;nbsp;in proving&amp;nbsp;their ideas&amp;nbsp;with code.&#xD;
    Having a shared model of the system promotes collaboration within the team, encouraging everyone to work towards the&#xD;
    same goal.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    With the support of appropriate tools, you can use a design model to generate an initial code for implementation. This&#xD;
    is referred to as &lt;strong>forward engineering&lt;/strong> or &lt;strong>code generation&lt;/strong>. You can also enhance design&#xD;
    models to include enough information to build the system.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Reverse engineering&lt;/strong> may also be applied to generate design models from existing implementations. You&#xD;
    can use this method to evaluate existing implementations.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Round-trip engineering&lt;/strong> combines both forward and reverse engineering techniques to ensure consistent&#xD;
    design and code. Combined with an iterative process and the right tools, round-trip engineering allows you to&#xD;
    synchronize the design and code during each iteration.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Capture requirements precisely&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Before building a system, it's critical to capture the requirements. Specifying the requirements using a precise and&#xD;
    unambiguous model helps to ensure that all stakeholders can understand and agree on the requirements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A model that separates the external behavior of the system from the implementation of it helps you focus on the&#xD;
    intended use of the system, without getting bogged down in implementation details.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Communicate decisions unambiguously&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The Unified Modeling Language (UML) is&amp;nbsp;a consistent notation that can be applied for system engineering, as well&#xD;
    as for business engineering. According to these excerpts from the UML specification, a standard notation::&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;p>&#xD;
            Serves as a language for communicating decisions that are not obvious or cannot be inferred from the code&#xD;
            itself.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p>&#xD;
            Provides semantics that are rich enough to capture all important strategic and tactical decisions.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p>&#xD;
            Offers a form concrete enough for humans to reason [about] and for tools to manipulate.&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    UML represents the convergence of the best practice in software modeling throughout the object-technology industry. For&#xD;
    more information on the UML, see &lt;a class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;
    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>[UML05]&lt;/a>.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
