<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-fj_9xjbrpaYNSETyCz5yJg" name="refactoring,_Poc7IPDzEdqYgerqi84oCA" guid="-fj_9xjbrpaYNSETyCz5yJg" changeDate="2008-01-16T14:54:37.000+0100" version="1.0.0" mainDescription="&lt;p>&#xD;&#xA;    Refactoring is a disciplined way to restructure code when small changes are made to the code to improve its design. An&#xD;&#xA;    important aspect of a refactoring is that it improves the design while not changing the behavior of the design; a&#xD;&#xA;    refactoring neither adds nor removes functionality.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Refactoring enables you to evolve the code slowly over time, to take an iterative and incremental approach to&#xD;&#xA;    implementation.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    These are the types of refactoring:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ol>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Code refactoring. Often referred to simply as refactoring, this is the refactoring of programming source code.&#xD;&#xA;        Examples of code refactorings include Rename Method, Encapsulate Field, Extract Class, Introduce Assertion, and&#xD;&#xA;        Pushdown Method.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Database refactoring. A database refactoring is a simple change to a database schema that improves its design while&#xD;&#xA;        retaining both its behavioral and informational semantics. Examples of database refactorings include Rename Column,&#xD;&#xA;        Split Table, Move Method to Database, Replace LOB with Table, Introduce Column Constraint, and Use Official Data&#xD;&#xA;        Source.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        User interface (UI) refactoring. A UI refactoring is a simple change to the UI which retains its semantics.&#xD;&#xA;        Examples of UI refactorings include Align Entry Fields, Apply Common Button Size, Apply Common Font, Indicate&#xD;&#xA;        Format, Reword in Active Voice, and Increase Color Contrast.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ol>&#xD;&#xA;&lt;p>&#xD;&#xA;    Martin Fowler [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html#FOW99&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>FOW99&lt;/a>] identifies four key reasons to refactor:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Refactoring improves the design of software.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Refactoring makes software easier to understand.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Refactoring helps you find bugs.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Refactoring helps you program faster.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Refactoring can improve the design of existing code, but it does not take the place of considering the design before&#xD;&#xA;    writing code. Refactoring instead changes the role of up-front design, allowing the strictly design work to be more&#xD;&#xA;    abstract. Small-scale, very tactical decisions can be made during the implementation of the solution with confidence&#xD;&#xA;    that refactoring will ensure a quality implementation at that level. The designing of the solution before&#xD;&#xA;    implementation will be more lightweight and focused on broad factors that will drive the implementation.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    There is an additional benefit of refactoring: it changes the way a developer thinks about the implementation when not&#xD;&#xA;    refactoring. The basic task of implementing a solution becomes solely about getting the solution to pass its developer&#xD;&#xA;    tests in the simplest way possible. Then the design of that solution can be examined and refactored separately. Even if&#xD;&#xA;    these two things -- implementation of the solution and then improvement -- are just a minute apart, it can be freeing&#xD;&#xA;    for a developer to single-mindedly create code that causes a test to pass, and then separately single-mindedly improve&#xD;&#xA;    that code.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    These are some additional resources:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;a href=&quot;http://www.refactoring.com/&quot; target=&quot;_blank&quot;>&lt;u>&lt;font&#xD;&#xA;        color=&quot;#0000ff&quot;>http://www.refactoring.com/&lt;/font>&lt;/u>&lt;/a>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;a href=&quot;http://www.agiledata.org/essays/databaseRefactoring.html&quot;>&lt;u>&lt;font&#xD;&#xA;        color=&quot;#0000ff&quot;>http://www.agiledata.org/essays/databaseRefactoring.html&lt;/font>&lt;/u>&lt;/a>&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>" longPresentationName="refactoring,_Poc7IPDzEdqYgerqi84oCA"/>
