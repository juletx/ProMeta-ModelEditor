<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="_QvmkAMM1EdmSIPI87WLu3g" name="patterns,_0YJvUMlgEdmt3adZL5Dmdw" guid="_QvmkAMM1EdmSIPI87WLu3g" changeDate="2008-09-03T14:26:48.000+0200" version="1.0.0" mainDescription="&lt;h4>&#xD;&#xA;    Origins&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    The idea of patterns as it is now applied to software design comes from the work of Christopher Alexander. He has&#xD;&#xA;    written widely on the subject of applying patterns to the design and construction of towns and buildings. Two of his&#xD;&#xA;    books, &lt;em>A Pattern Language&lt;/em> [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>ALE77&lt;/a>] and &lt;em>The Timeless Way of Building&lt;/em> [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>ALE79&lt;/a>] have had the greatest impact on the software community and the adoption of&#xD;&#xA;    software patterns for the design of software. His concepts of patterns and pattern language provide a model for the&#xD;&#xA;    capture of software design expertise in a form that can then be reapplied in recurring situations.&amp;nbsp;&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    A definition of patterns&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Today, the most commonly used definition of software patterns is from [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>GAM95&lt;/a>]:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;blockquote>&#xD;&#xA;    &lt;p>&#xD;&#xA;        &quot;A design pattern describes the problem, a solution to the problem consisting of a general arrangement of objects&#xD;&#xA;        and classes, when to apply the solution, and the consequences of applying the solution.&quot;&#xD;&#xA;    &lt;/p>&#xD;&#xA;&lt;/blockquote>&#xD;&#xA;&lt;p>&#xD;&#xA;    This definition often serves only as a starting point, however. A richer definition, based on Alexander's work, is&#xD;&#xA;    offered by Gabriel in his book, &lt;em>A Timeless Way of Hacking&lt;/em> [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>ALU03&lt;/a>], in which each pattern is a three-part rule that expresses relationships&#xD;&#xA;    among a certain context, a certain system of forces that occur repeatedly in that context, and a certain software&#xD;&#xA;    configuration that allows these forces to resolve themselves.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Describing patterns&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    It is commonplace to describe patterns&amp;nbsp;using the&amp;nbsp;format made popular by Erich Gamma and his three colleagues&#xD;&#xA;    [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>GAM95&lt;/a>]. They have come to be known as the Gang of Four (GoF); therefore, their&#xD;&#xA;    description is known as the &lt;strong>GoF format&lt;/strong>. The GoF format uses the following keywords to describe&#xD;&#xA;    object-oriented design patterns:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Pattern name and classification:&lt;/strong> Naming the pattern allows design to work at a higher level of&#xD;&#xA;            abstraction, using a vocabulary of patterns. Gamma says that finding a good name is one of the hardest problems&#xD;&#xA;            of developing a catalogue of patterns (see &lt;strong>Pattern catalogues&lt;/strong> later in this section).&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Intent:&lt;/strong> An answer to questions such as: What does the pattern do? What problem does it&#xD;&#xA;            address?&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Also known as:&lt;/strong> Other names for the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Motivation:&lt;/strong> A concrete scenario that illustrates a design problem and how the pattern solves&#xD;&#xA;            the problem.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Applicability:&lt;/strong> Instructions for how you can recognize situations in which patterns are&#xD;&#xA;            applicable.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Structure:&lt;/strong> A graphical representation of the classes in the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Participants:&lt;/strong> The responsibilities of the classes and objects that participate in the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Collaborations:&lt;/strong> How participants collaborate to fulfill their responsibilities.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Consequences:&lt;/strong> The results, side effects and trade offs caused by using the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Implementation:&lt;/strong> Guidance on the implementation of the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Sample code:&lt;/strong> Code fragments that illustrate the pattern's implementation.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Known uses:&lt;/strong> Where to find real-world examples of the pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Related patterns:&lt;/strong> Synergies, differences, and other pattern relationships.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Although the GoF format is specifically intended for object-oriented development, you can use it, with slight&#xD;&#xA;    modification, to address other software patterns. A more general keyword format for software patterns based on&#xD;&#xA;    Alexander's principles uses keywords such as &lt;em>problem&lt;/em>, &lt;em>context&lt;/em>, &lt;em>forces&lt;/em> and &lt;em>solution&lt;/em>.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Pattern catalogs&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    To assist with the identification and selection of patterns, various classification schemes have been proposed. One of&#xD;&#xA;    the early schemes, proposed by Buschmann and his associates, [&lt;a class=&quot;elementLinkWithUserText&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html&quot;&#xD;&#xA;    guid=&quot;_9ToeIB83Edqsvps02rpOOg&quot;>BUS96&lt;/a>] uses three classifiers: granularity, functionality, and structured&#xD;&#xA;    principles. Of those three classifiers, it is their granularity classifier that has remained popular. Granularity&#xD;&#xA;    classifies patterns into three levels of abstraction:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Architectural patterns:&lt;/strong> Architectural patterns express the fundamental structure of a software&#xD;&#xA;            scheme. Examples of architectural pattern include: layers, pipes and filters, and the model view controller&#xD;&#xA;            pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Design patterns:&lt;/strong> Software architecture usually consists of smaller architectural units that&#xD;&#xA;            are described by design patterns. The GoF pattern is an example of a design pattern.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;p>&#xD;&#xA;            &lt;strong>Idioms.&lt;/strong> An idiom is the lowest-level pattern, and it is specific to a programming language.&#xD;&#xA;        &lt;/p>&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Buschmann and his colleagues introduced four groups for categorizing architectural patterns:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Structure&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Distributed systems&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Interactive systems&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Adaptable systems&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    The following table shows the categorization of their architectural patterns.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;85%&quot; summary=&quot;Categories for Architectural Patterns [BUS96]&quot; border=&quot;1&quot;&#xD;&#xA;valign=&quot;top&quot;>&#xD;&#xA;    &lt;caption>&#xD;&#xA;        &lt;strong>Categories for Architectural Patterns&lt;br />&#xD;&#xA;        &lt;/strong>&#xD;&#xA;    &lt;/caption>&#xD;&#xA;    &lt;tbody>&#xD;&#xA;        &lt;tr>&#xD;&#xA;            &lt;th scope=&quot;col&quot;>&#xD;&#xA;                &lt;div align=&quot;center&quot;>&#xD;&#xA;                    &lt;strong>Category&lt;/strong>&#xD;&#xA;                &lt;/div>&#xD;&#xA;            &lt;/th>&#xD;&#xA;            &lt;th scope=&quot;col&quot;>&#xD;&#xA;                &lt;div align=&quot;center&quot;>&#xD;&#xA;                    &lt;strong>Pattern&lt;/strong>&#xD;&#xA;                &lt;/div>&#xD;&#xA;            &lt;/th>&#xD;&#xA;        &lt;/tr>&#xD;&#xA;        &lt;tr>&#xD;&#xA;            &lt;td>&#xD;&#xA;                Structure&#xD;&#xA;            &lt;/td>&#xD;&#xA;            &lt;td>&#xD;&#xA;                &lt;p>&#xD;&#xA;                    Layers&lt;br />&#xD;&#xA;                    Pipes and filters&lt;br />&#xD;&#xA;                    Blackboard&#xD;&#xA;                &lt;/p>&#xD;&#xA;            &lt;/td>&#xD;&#xA;        &lt;/tr>&#xD;&#xA;        &lt;tr>&#xD;&#xA;            &lt;td>&#xD;&#xA;                Distributed systems&#xD;&#xA;            &lt;/td>&#xD;&#xA;            &lt;td>&#xD;&#xA;                Broker&#xD;&#xA;            &lt;/td>&#xD;&#xA;        &lt;/tr>&#xD;&#xA;        &lt;tr>&#xD;&#xA;            &lt;td>&#xD;&#xA;                Interactive systems&#xD;&#xA;            &lt;/td>&#xD;&#xA;            &lt;td>&#xD;&#xA;                Model view controller&lt;br />&#xD;&#xA;                Presentation abstraction control&#xD;&#xA;            &lt;/td>&#xD;&#xA;        &lt;/tr>&#xD;&#xA;        &lt;tr>&#xD;&#xA;            &lt;td>&#xD;&#xA;                &lt;p>&#xD;&#xA;                    Adaptable systems&#xD;&#xA;                &lt;/p>&#xD;&#xA;            &lt;/td>&#xD;&#xA;            &lt;td>&#xD;&#xA;                &lt;p>&#xD;&#xA;                    Reflection&lt;br />&#xD;&#xA;                    Micro kernel&#xD;&#xA;                &lt;/p>&#xD;&#xA;            &lt;/td>&#xD;&#xA;        &lt;/tr>&#xD;&#xA;    &lt;/tbody>&#xD;&#xA;&lt;/table>&#xD;&#xA;&lt;p>&#xD;&#xA;    For design patterns, Gamma's group categorized their design patterns by purpose, using three categories:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Creational&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Structural&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Behavioral&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Pattern languages&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    In addition to the concept of patterns, Alexander also gave the software community the concept of a pattern language.&#xD;&#xA;    The purpose of developing a pattern language was to provide a vocabulary of design principles (patterns) that would&#xD;&#xA;    allow those who work, study, or live in buildings to communicate effectively with the planners and designers of those&#xD;&#xA;    buildings. Alexander explains that when using a pattern language:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;blockquote>&#xD;&#xA;    &lt;p>&#xD;&#xA;        We always use it as a sequence, going through the patterns, moving always from the larger patterns to the smaller,&#xD;&#xA;        always from the ones that create structure to the ones which then embellish those structures, and then to those&#xD;&#xA;        that embellish the embellishments.&#xD;&#xA;    &lt;/p>&#xD;&#xA;&lt;/blockquote>&#xD;&#xA;&lt;p>&#xD;&#xA;    In applying patterns in this way, Alexander advocated the use of generative pattern languages, ones that, given an&#xD;&#xA;    initial context, would always lead to good design.&amp;nbsp; Alexander&amp;nbsp;states:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;blockquote>&#xD;&#xA;    &lt;p>&#xD;&#xA;        Thus, as in the case of natural languages, the pattern language is generative. It not only tells us the rules of&#xD;&#xA;        arrangement, but shows us how to construct arrangements - as many as we want - which satisfies the rules.&#xD;&#xA;    &lt;/p>&#xD;&#xA;&lt;/blockquote>&#xD;&#xA;&lt;p>&#xD;&#xA;    In the application of software patterns, pattern names provide a vocabulary for the communication of software ideas.&#xD;&#xA;    The sequential application of patterns finds application in software design processes, both waterfall and iterative,&#xD;&#xA;    that successively apply architectural patterns, and then design patterns, and, finally, idioms to design and implement&#xD;&#xA;    a software system. Software processes, however, rely on the skills of the Architect and Developer roles to guide the&#xD;&#xA;    application of patterns, rather than a generative pattern language.&#xD;&#xA;&lt;/p>" longPresentationName="patterns,_0YJvUMlgEdmt3adZL5Dmdw"/>
