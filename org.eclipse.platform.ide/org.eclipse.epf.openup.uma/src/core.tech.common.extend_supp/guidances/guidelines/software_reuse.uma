<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-Vp61zQMUoP-Icm5jgDar7A" name="new_guideline,_vO2uoO0OEduUpsu85bVhiQ" guid="-Vp61zQMUoP-Icm5jgDar7A" changeDate="2008-02-15T14:30:27.000+0100" version="1.0.0" mainDescription="&lt;p>&#xD;&#xA;    Maximizing reuse has always been an important goal of software development. It's better to re-use than to expend the&#xD;&#xA;    cost of creating something new, testing it, and releasing it for the first time with the risk of hidden problems that&#xD;&#xA;    all new software has. Languages, particularly object-oriented ones, have been developed to make reuse easier. But a&#xD;&#xA;    language alone isn't enough to provide cost effective reuse. The bulk of reusable software comes from skilled&#xD;&#xA;    developers and architects who are able to identify and leverage reuse opportunities.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    What is a Reusable Asset?&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    The following are some examples of reusable software assets:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Architectural frameworks&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Architectural mechanisms&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Architectural decisions&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Constraints&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Applications&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Components&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        COTS software&amp;nbsp;&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Identifying Reuse Opportunities&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    There are three perspectives to look at when reusing software: code (implementation), design, and framework or&#xD;&#xA;    architecture.&amp;nbsp; Architects should look to reuse significant application frameworks such as layers that can be&#xD;&#xA;    applied to many different types of applications (for more information, see &lt;a class=&quot;elementLinkWithType&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.extend_supp/guidances/guidelines/layering_F169CF07.html&quot;&#xD;&#xA;    guid=&quot;_0gpkAMlgEdmt3adZL5Dmdw&quot;>Guideline: Layering&lt;/a>. Developers should look to designs and &lt;a class=&quot;elementLink&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/pattern_10BE6D96.html&quot;&#xD;&#xA;    guid=&quot;_0YJvUMlgEdmt3adZL5Dmdw&quot;>Pattern&lt;/a>s that can be reused to produce desired behavior or robust structures. They&#xD;&#xA;    should also look at how to reduce the amount of code that needs to be written by leveraging stable components and code&#xD;&#xA;    that has been proven in production environments.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The best way to enable a team to find opportunities for reuse is to exercise excellent design and coding practices.&#xD;&#xA;    It's difficult to find code and design that can be reused when dealing with large classes, classes that don't have a&#xD;&#xA;    clearly defined focus, or classes with relationships that are difficult to understand. Classes should be small, easy to&#xD;&#xA;    understand, and highly cohesive to make it easier to identify reuse opportunities. Any functionality that can be&#xD;&#xA;    reasonably separated into another class should be. Another way of saying this is that any concept that could be applied&#xD;&#xA;    to more than one type of class should be its own class.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    For example, if some calculations are added to an existing class, it may make sense to then refactor those calculations&#xD;&#xA;    into a new helper class. Those calculations can&amp;nbsp;then be re-used in any number of other classes without the burden&#xD;&#xA;    of having to know about the functionality of the original class.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The simplest but least efficient way to identify reuse opportunities is to &quot;smell&quot; similar code. A developer may recall&#xD;&#xA;    doing something similar to what they're designing or implementing now. Once the previous implementation has been&#xD;&#xA;    discovered or recalled it can be reused. Developers will always find reuse opportunities this way. But the unstructured&#xD;&#xA;    nature of it won't maximize the potential areas for reuse.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Collaboration is a good technique for identifying reuse opportunities. It provides a structure where identifying reuse&#xD;&#xA;    - instead of writing code - is the goal of the exercise. And the more brains that are looking for reuse opportunities,&#xD;&#xA;    the more likely it is that they'll be found. A brainstorming or review meeting that focuses on identifying reuse&#xD;&#xA;    opportunities would be useful to support this.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Patterns are good ways to find reuse opportunities in designs and frameworks. See &lt;a class=&quot;elementLinkWithType&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/pattern_10BE6D96.html&quot;&#xD;&#xA;    guid=&quot;_0YJvUMlgEdmt3adZL5Dmdw&quot;>Concept: Pattern&lt;/a>&amp;nbsp;for more information.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Analyzing behavior is another good way to identify potential areas for reuse. Analyze how classes need to collaborate&#xD;&#xA;    in order to deliver some specific functionality such as a requirement or feature. This collaboration can be documented&#xD;&#xA;    in sequence (behavior) and class (structure) diagrams and can be reused in similar circumstances.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    After looking for similar behavior and returned values, then look for similarity of parameters. If their&#xD;&#xA;    interfaces&amp;nbsp;are not an exact match for the component interfaces being proposed, you can modify the&#xD;&#xA;    proposed&amp;nbsp;signatures to increase the degree of reuse. Some design mechanisms, such as performance or security&#xD;&#xA;    requirements, may disqualify a component from reuse even when there is&amp;nbsp;a perfect match between operation&#xD;&#xA;    signatures.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p align=&quot;left&quot;>&#xD;&#xA;    A common set of components may exist that provides many of the &lt;a class=&quot;elementLink&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/arch_mechanism_2932DFB6.html&quot;&#xD;&#xA;    guid=&quot;_mzxI0A4LEduibvKwrGxWxA&quot;>Architectural Mechanism&lt;/a> that you need&amp;nbsp;for the new system. These components may&#xD;&#xA;    be available either because they were developed or purchased previously for&amp;nbsp;similar systems. Given their&#xD;&#xA;    suitability and compatibility within the software architecture, there may be a need to reverse-engineer these&#xD;&#xA;    components to represent them in a design model and reuse them in a project.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p align=&quot;left&quot;>&#xD;&#xA;    Similar thinking applies to&amp;nbsp;existing databases. Part of the information to be used by the application under&#xD;&#xA;    development may already reside in a database. You may be able to get the classes that represent the database structures&#xD;&#xA;    that hold this information by reverse-engineering the database.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;a class=&quot;elementLink&quot; href=&quot;./../../../core.tech.common.extend_supp/guidances/concepts/refactoring_1B63BA3B.html&quot;&#xD;&#xA;    guid=&quot;_Poc7IPDzEdqYgerqi84oCA&quot;>Refactoring&lt;/a> should always be considered when reusing code. Code (or design) is often&#xD;&#xA;    not originally written for re-use, or reusable code may not be a perfect fit for a new situation.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Assessing and Selecting Assets to Reuse&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    To assess and select assets to reuse on your project, you need to understand the requirements of the system's&#xD;&#xA;    environment. You also need to understand the scope and general functionality of the system that the stakeholders&#xD;&#xA;    require. There are several types of assets to consider, including (but not limited to): reference architectures;&#xD;&#xA;    frameworks; patterns; analysis mechanisms; classes; and experience. You can search asset&amp;nbsp;repositories (internal or&#xD;&#xA;    external to your organization) and industry literature to identify assets or similar projects.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    You need to assess whether available assets contribute to solving the key challenges of the current project and whether&#xD;&#xA;    they are compatible with the project's architectural constraints. You also need to analyze the extent of the fit&#xD;&#xA;    between assets and requirements, considering whether any of the requirements are negotiable (to enable use of the&#xD;&#xA;    asset). Also, assess whether the asset could be modified or extended to satisfy requirements, as well as what the&#xD;&#xA;    tradeoffs in adopting it are, in terms of cost, risk, and functionality.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Leverage reuse of existing components by evaluating their interfaces and the behavior that they provide. Reuse&#xD;&#xA;    components when their interfaces are similar or match the interfaces of components you would need to develop from&#xD;&#xA;    scratch. If not similar, modify the newly identified interfaces so you improve the fit with existing components&#xD;&#xA;    interfaces. Work with developers to gain consensus on the suitability of using existing components.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Finally, decide, in principle, whether to use one or more assets, and record the rationale for this decision.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Reuse Techniques&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Reuse can be performed differently depending on the capabilities of the implementation environment. The simplest&#xD;&#xA;    technique is to copy the code from one place to another. This isn't advisable because it's not really reuse. Multiple&#xD;&#xA;    copies of source code are difficult to maintain and can eventually diverge from each other. Reuse is about using the&#xD;&#xA;    same code to perform similar tasks as a way to increase quality and reduce overhead.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Some languages, such as C++, support templates. Templates, sometimes referred to as parameterized code, are a precursor&#xD;&#xA;    to patterns. Templates are code with parameters that are applied just when the code's needed, at compile time. The C++&#xD;&#xA;    Standard Template Library (STL) is one example. It provides many types of reusable containers (lists, sets, safe&#xD;&#xA;    arrays, etc) that don't have some of the drawbacks of inheritance. Templates such as these are also useful as mix-in&#xD;&#xA;    classes in languages like C++ that support multiple inheritance. Because mix-ins are implemented as templates, they&#xD;&#xA;    allow for a type of multiple inheritance without the baggage.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Inheritance and Aggregation&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Inheritance (also known as generalization) is an easy way to implement polymorphism and has been used as the primary&#xD;&#xA;    mechanism for reuse in modern object-oriented languages. This is unfortunate, as inheritance imposes a rigid structure&#xD;&#xA;    on the software's design that is difficult to change. Any inheritance hierarchy that shares code from parents to&#xD;&#xA;    children will have problems when it grows to be three or more levels deep. Too many exceptions occur to maintain a pure&#xD;&#xA;    &quot;is-a&quot; relationship between parents and children, where children are always considered to have all the properties and&#xD;&#xA;    behaviors of the parents. Inheritance should be used to share definitions (interfaces), not implementations. Years of&#xD;&#xA;    difficulties with inheriting implementations have made this practice a primary object-oriented design principle.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Whenever inheritance is used, it is best to have only the last child class (leaf node) of the inheritance hierarchy be&#xD;&#xA;    instantiated. All parent classes should be abstract. This is because a class that tries to be both reusable and&#xD;&#xA;    concrete - to provide reusable and specific behavior at the same time - almost always fails to fulfill either goal.&#xD;&#xA;    This is a dimension of cohesiveness. One thing that makes a class cohesive is that it's dedicated to reuse or dedicated&#xD;&#xA;    to a specific implementation, but not both.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Aggregation is a technique that collects or aggregates functionality into larger elements of functionality. It provides&#xD;&#xA;    a structure that's far more flexible and reusable than inheritance. It's better to reuse implementation and design by&#xD;&#xA;    aggregating small pieces of functionality together rather than trying to inherit the functionality from a parent.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    You may also find reuse opportunities by reviewing interfaces. If interfaces describe similar behavior it may be&#xD;&#xA;    possible to eliminate one of the interfaces, have just one implementation realize both interfaces, or refactor the&#xD;&#xA;    interfaces to put redundant content in a new, simpler interface.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Finding Reusable Code&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    There are many sources of reusable code beyond what the developers are writing for a specific project. Other places&#xD;&#xA;    from which to harvest code include the following:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Internal (corporate) code libraries&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Third party libraries&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Built-in language libraries&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Code samples from tutorials, examples, books, etc.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Local code guru or knowledgeable colleague&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Existing system code&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Open source products (be sure to follow any licensing agreements)&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Also, many tools that generate code will generate comprehensive code based on minimal specification. For example, a&#xD;&#xA;    design tool might generate the member variable plus a get and a set operation when the designer specifies an attribute.&#xD;&#xA;    Other more sophisticated tools with knowledge of a specific framework can generate voluminous code to ensure that a&#xD;&#xA;    class conforms to the framework. An example of this would be a tool that generates significant additional code when a&#xD;&#xA;    class is marked as a Java entity bean. This sort of consistent transformation from a specification (the design) to an&#xD;&#xA;    implementation (the code) could be considered a form of code reuse as well.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Don't Reuse Everything&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Reuse makes code and design cheap to use but expensive to build. It requires experience and thoughtful consideration to&#xD;&#xA;    create an implementation or design that's abstract enough for others to re-use, but concrete enough to be truly useful.&#xD;&#xA;    Reusable code must also be maintained. Many organizations have difficulty assigning responsibility for maintaining&#xD;&#xA;    reusable code if they don't have a group dedicated to reuse.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    It's usually not a good idea to create code or designs for reuse unless you know it's going to be reused. It's better&#xD;&#xA;    to refactor software to be more reusable after it's discovered that they can be reused. One rule of thumb is to write&#xD;&#xA;    for reuse only when you know you'll use it at least 3 times. Otherwise the cost of building and maintaining that part&#xD;&#xA;    of the software will not be recovered by reduced overhead in other areas of development.&#xD;&#xA;&lt;/p>" longPresentationName="new_guideline,_vO2uoO0OEduUpsu85bVhiQ"/>
