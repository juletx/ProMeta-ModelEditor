<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-4HHmcQny_Q08Xj_3Q7Sfig" name="new_concept,_mlKb8JyJEdy9brKHb521mQ" guid="-4HHmcQny_Q08Xj_3Q7Sfig" changeDate="2008-08-07T13:56:11.000+0200" version="7.2.0" mainDescription="&lt;h4>&#xD;&#xA;    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introduction&lt;/a>&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Design must define enough of the system so that it can be implemented unambiguously. What constitutes enough varies&#xD;&#xA;    from project to project and company to company.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In some cases the design resembles a sketch, elaborated only far enough to ensure that the implementer can proceed (a&#xD;&#xA;    &quot;sketch and code&quot; approach). The degree of specification varies with the expertise of the implementer, the complexity&#xD;&#xA;    of the design, and the risk that the design might be misconstrued.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In other cases, the design is elaborated to the point that the design can be transformed automatically into code. This&#xD;&#xA;    typically involves extensions to standard UML to represent language and/or environment specific semantics.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The design may also be hierarchical, such as the following:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        a high level design model which sketches an overview of the overall system&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        a subsystem specification model which precisely specifies the required interfaces and behavior of major subsystems&#xD;&#xA;        within the system&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        a detailed design model for the internals of subsystems&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    The sections below describe some different options for relating a design and implementation, and discuss benefits and&#xD;&#xA;    drawbacks of these approaches.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    &lt;a id=&quot;sketch&quot; name=&quot;sketch&quot;>Sketch and Code&lt;/a>&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    One common approach to design is to sketch out the design at a fairly abstract level, and then move directly to code.&#xD;&#xA;    Maintenance of the design model is manual.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In this approach, we let a design class be an abstraction of several code-level classes. We recommend that you map each&#xD;&#xA;    design class to one &quot;head&quot; class that, in turn, can use several &quot;helper&quot; classes to perform its behavior. You can use&#xD;&#xA;    &quot;helper&quot; classes to implement a complex attribute or to build a data structure that you need for the implementation of&#xD;&#xA;    an operation. In design, you don't model the &quot;helper&quot; classes and you only model the key attributes, relationships, and&#xD;&#xA;    operations defined by the head class. The purpose of such a model is to abstract away details that can be completed by&#xD;&#xA;    the implementer.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    This approach is extended to apply to the other design model elements. You may have design interfaces which are more&#xD;&#xA;    abstract than the code-level interfaces, and so on.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    &lt;a id=&quot;round&quot; name=&quot;round&quot;>Round-Trip Engineering&lt;/a>&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    In round-trip engineering environments, the design model evolves to a level of detail where it becomes a visual&#xD;&#xA;    representation of the code. The code and its visual representation are synchronized (with tool support).&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The following are some options for representing a Design Model in a round-trip engineering context.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;b>&lt;a id=&quot;trace&quot; name=&quot;trace&quot;>High Level Design Model and Detailed Design Model&lt;/a>&lt;/b>&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In this approach, there are two levels of design model maintained. Each high level design element is an abstraction of&#xD;&#xA;    one or more detailed elements in the round-tripped model. For example, a design class may map to one &quot;head&quot; class and&#xD;&#xA;    several &quot;helper&quot; classes, just as in the &quot;sketch and code&quot; approach described previously. Traceability from the high&#xD;&#xA;    level design model elements to round-trip model elements can help maintain consistency between the two models.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Although this can help abstract away less important details, this benefit must be balanced against the effort required&#xD;&#xA;    to maintain consistency between the models.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;b>&lt;a id=&quot;evolves&quot; name=&quot;evolves&quot;>Single Evolving Design Model&lt;/a>&lt;/b>&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In this approach, there is a single Design Model. Initial sketches of design elements evolve to the point where they&#xD;&#xA;    can be synchronized with code. Diagrams, such as those used to describe design use-case realizations, initially&#xD;&#xA;    reference sketched design classes, but eventually reference language-specific classes. High level descriptions of the&#xD;&#xA;    design are maintained as needed, such as:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        diagrams of the logical structure of the system,&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        subsystem/component specifications,&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        design patterns / mechanisms.&lt;br />&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Such a model is easier to maintain consistent with the implementation.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    &lt;a id=&quot;specification&quot; name=&quot;specification&quot;>Specification and Realization Models&lt;/a>&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    A related approach is to define the design in terms of specifications for major subsystems, detailed to the point where&#xD;&#xA;    client implementations can compile against them.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The detailed design of the subsystem realization can be modeled and maintained separately from this specification&#xD;&#xA;    model.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Models can be detailed and used to generate an implementation. Both structure (class and package diagrams) and behavior&#xD;&#xA;    diagrams (such as collaboration, state, and activity diagrams) can be used to generate executable code. These initial&#xD;&#xA;    versions can be further refined as needed.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The design may be platform-independent to varying degrees. Platform-specific design models or even code can be&#xD;&#xA;    generated by transformations that apply various rules to map high-level abstractions of platform-specific elements.&#xD;&#xA;    This is the focus of the Object Management Group (OMG) Model-Driven Architecture (MDA) &lt;a href=&quot;http://www.omg.org/&quot;&#xD;&#xA;    target=&quot;_blank&quot;>(http://www.omg.org&lt;/a>) initiative.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Platform-specific visual models can be used to generate an initial code framework. This framework can be further&#xD;&#xA;    elaborated with additional code not specified in the design.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Patterns&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Standard patterns can be applied to generate design and code elements from related design and implementation. For&#xD;&#xA;    example, a standard transformation pattern can be applied to a data table to create Java&amp;trade; classes to access the data&#xD;&#xA;    table. Another example is using an &lt;a href=&quot;http://www.eclipse.org/emf/&quot; target=&quot;_blank&quot;>Eclipse Modeling Framework&lt;/a>&#xD;&#xA;    to generate code for storing data that matches the model and to generate a user interface implementation for populating&#xD;&#xA;    data. A pattern or transformation engine can be used to create the implementation, or the implementation can be done by&#xD;&#xA;    hand. Pattern engines are easier and more reliable, but handwritten code implementing a defined pattern will have fewer&#xD;&#xA;    errors than handwritten code implementing a novel or unique design.&#xD;&#xA;&lt;/p>&lt;br />" longPresentationName="new_concept,_mlKb8JyJEdy9brKHb521mQ"/>
