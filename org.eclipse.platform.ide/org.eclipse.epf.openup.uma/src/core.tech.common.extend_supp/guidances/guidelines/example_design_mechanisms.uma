<?xml version="1.0" encoding="UTF-8"?><org.eclipse.epf.uma:ContentDescription xmlns:epf="http://www.eclipse.org/epf" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:xmi="http://www.omg.org/XMI" xmi:version="2.0" epf:version="1.5.1" xmi:id="-mAo18f36rZ1R98kpZX7HMw" name="new_guideline,_K32gYAoBEdu0OeEVPFogVA" guid="-mAo18f36rZ1R98kpZX7HMw" changeDate="2008-03-11T19:28:25.000+0100" version="1.0.0">
  <mainDescription>&lt;h3&gt;&#xD;
    Design Mechanism Characteristics and Mapping&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    Consider the analysis mechanism for &lt;strong&gt;persistence&lt;/strong&gt;.&#xD;
&lt;/p&gt;&#xD;
&lt;ul&gt;&#xD;
    &lt;li&gt;&#xD;
        There might be a need for many (2,000) small objects (200 bytes each) to be stored for a few seconds, with no need&#xD;
        for them to survive thereafter.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        There might be a need for several very large objects to be stored permanently on disk for several months, never&#xD;
        updated, but with sophisticated means of retrieval.&#xD;
    &lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;p&gt;&#xD;
    These objects require different support for persistency. The best option depends on the characteristics of the design&#xD;
    mechanism:&#xD;
&lt;/p&gt;&#xD;
&lt;ul&gt;&#xD;
    &lt;li&gt;&#xD;
        &lt;b&gt;In-memory storag&lt;/b&gt;&lt;strong&gt;e:&lt;/strong&gt; For up to 1 Mb total (size x volume); very fast access for read, write,&#xD;
        update.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        &lt;b&gt;Flash card&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; For up to 8 Mb; slow update and write access; moderate read access.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        &lt;b&gt;Binary file&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; For 100 Kb to 200 Mb; slow update; slow read-and-write access.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        &lt;b&gt;Database management system (DBMS)&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; For 100 Kb and upward (essentially no upper limit); even&#xD;
        slower update and read-and-write access.&#xD;
    &lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;p&gt;&#xD;
    Note that these speeds are rated as slow only as compared to in-memory storage. Obviously, in some environments,&#xD;
    caching can improve apparent access times. (See Figure 1.)&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p align="center"&gt;&#xD;
        &lt;img title="Figure 1. Mapping Analysis Mechanisms to Design Mechanisms and Classes" height="221"&#xD;
        alt="Mapping Analysis Mechanisms to Design Mechanisms and Classes" src="resources/co_dmec1.gif" width="372" /&gt;&#xD;
    &lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;div align="center"&gt;&#xD;
    &lt;p&gt;&#xD;
        &lt;strong&gt;Figure 1. Mapping Analysis Mechanisms to Design Mechanisms and Classes&lt;/strong&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;h3 align="left"&gt;&#xD;
        Mapping Design Mechanisms to Implementation Mechanisms&#xD;
    &lt;/h3&gt;&#xD;
    &lt;p align="left"&gt;&#xD;
        The &lt;b&gt;persistence&lt;/b&gt; design mechanisms can be mapped to implementation mechanisms as Figure 2 shows:&#xD;
    &lt;/p&gt;&#xD;
    &lt;p align="center"&gt;&#xD;
        &lt;img title="Figure 2. How persistence design mechanism map to implementation mechanism" height="216"&#xD;
        alt="How persistence design mechanism map to implementation mechanism" src="resources/co_dmec2.gif" width="325" /&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;p align="center"&gt;&#xD;
        &lt;strong&gt;Figure 2. How persistence design mechanism map to implementation mechanism&lt;/strong&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;p align="left"&gt;&#xD;
        A possible mapping between analysis mechanisms and design mechanisms. Dotted arrows mean "is specialized by,"&#xD;
        implying that the characteristics of the design mechanisms are inherited from the analysis mechanisms but that they&#xD;
        will be specialized and refined.&#xD;
    &lt;/p&gt;&#xD;
    &lt;p align="left"&gt;&#xD;
        After you have finished optimizing the mechanisms, the following mappings exist (see Figure 3):&#xD;
    &lt;/p&gt;&#xD;
    &lt;blockquote&gt;&#xD;
        &lt;p align="center"&gt;&#xD;
            &lt;img title="Figure 3. Mapping structure after optimizing the mechanisms" height="110"&#xD;
            alt="Illustration of mapping structure after optimizing the mechanisms" src="resources/co_dmec3.gif"&#xD;
            width="418" /&gt;&#xD;
        &lt;/p&gt;&#xD;
        &lt;p class="picturetext" align="center"&gt;&#xD;
            &lt;strong&gt;Figure 3. Mapping structure after optimizing the mechanisms&lt;/strong&gt;&#xD;
        &lt;/p&gt;&#xD;
        &lt;p class="picturetext" align="left"&gt;&#xD;
            The design decisions for a client class in terms of mappings between mechanisms. &lt;font&#xD;
            face="Courier New, Courier, mono"&gt;Flight&lt;/font&gt; class needs two forms of persistency&lt;strong&gt;:&lt;/strong&gt;&#xD;
            &lt;strong&gt;in-memory storage&lt;/strong&gt;, implemented by a predefined library routine, and &lt;strong&gt;a&#xD;
            database,&lt;/strong&gt; implemented with an off-the-shelf ObjectStorage product.&#xD;
        &lt;/p&gt;&#xD;
    &lt;/blockquote&gt;&#xD;
    &lt;p align="left"&gt;&#xD;
        The map must be navigable in both directions to make it easy to determine client classes when changing&#xD;
        implementation mechanisms.&#xD;
    &lt;/p&gt;&#xD;
    &lt;h4 align="left"&gt;&#xD;
        Refining the mapping between design and implementation mechanisms&#xD;
    &lt;/h4&gt;&#xD;
&lt;/div&gt;&#xD;
&lt;p&gt;&#xD;
    Initially, the mapping between design mechanisms and implementation mechanisms is likely to be less than optimal, but&#xD;
    it will get the project running, identify unforeseen risks, and trigger further investigations and evaluations. As the&#xD;
    project continues and you gain more knowledge, you will need to refine the mapping.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    Proceed iteratively to refine the mapping between design and implementation mechanisms. Eliminate redundant paths,&#xD;
    working both top-down and bottom-up.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    &lt;b&gt;Working top-down:&lt;/b&gt; When working top-down (from top to bottom), new and refined use-case realizations will put new&#xD;
    requirements on the necessary design mechanisms through the analysis mechanisms that you need. These new requirements&#xD;
    might uncover additional characteristics of a design mechanism, forcing a split between mechanisms. A compromise&#xD;
    between the system's complexity and its performance is also necessary:&#xD;
&lt;/p&gt;&#xD;
&lt;ul&gt;&#xD;
    &lt;li&gt;&#xD;
        Too many different design mechanisms make the system too complex.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        Too few design mechanisms can create performance problems for implementation mechanisms that stretch the limits of&#xD;
        the reasonable ranges of the values of their characteristics.&#xD;
    &lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;p&gt;&#xD;
    &lt;b&gt;Working bottom-up:&lt;/b&gt; When working bottom-up (from bottom to top) and investigating the available implementation&#xD;
    mechanisms, you might find products that satisfy several design mechanisms at once, but force some adaptation or&#xD;
    repartitioning of your design mechanisms. You want to minimize the number of implementation mechanisms you use, but too&#xD;
    few of them can also lead to performance problems.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    After you decide to use a DBMS to store class A objects, you might be tempted to use it to store all objects in the&#xD;
    system. This could be very inefficient or very cumbersome. Not all objects that require persistency need to be stored&#xD;
    in the DBMS. Some objects may be persistent, but one application may access them frequently, while other applications&#xD;
    access them only infrequently. A hybrid strategy, in which the object is read from the DBMS into memory and&#xD;
    periodically synchronized, may be the best approach.&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p class="example"&gt;&#xD;
        &lt;b&gt;Example&lt;/b&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;p class="example"&gt;&#xD;
        A flight can be stored both in memory for fast access and in a DBMS for long-term persistency. However, this&#xD;
        triggers a need for a mechanism to synchronize both.&#xD;
    &lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;&#xD;
    It is not uncommon to have more than one design mechanism associated with a client class as a compromise between&#xD;
    different characteristics.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    Because implementation mechanisms often come in bundles in off-the-shelf components (operating systems and middleware&#xD;
    products), some optimization based on cost, impedance mismatch, or uniformity of style needs to occur. Also, mechanisms&#xD;
    are often interdependent, which makes clear separation of services into design mechanisms difficult.&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p class="example"&gt;&#xD;
        &lt;b&gt;Examples&lt;/b&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;ul&gt;&#xD;
        &lt;li&gt;&#xD;
            The notification mechanism can be based on the inter-process communication mechanism.&#xD;
        &lt;/li&gt;&#xD;
        &lt;li&gt;&#xD;
            The error reporting mechanism can be based on the persistency mechanism.&#xD;
        &lt;/li&gt;&#xD;
    &lt;/ul&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;&#xD;
    Refinement continues over the whole Elaboration phase, and is always a compromise between:&#xD;
&lt;/p&gt;&#xD;
&lt;ul&gt;&#xD;
    &lt;li&gt;&#xD;
        An exact fit with the requirements of the clients of the design mechanism, in terms of the expected&#xD;
        characteristics.&#xD;
    &lt;/li&gt;&#xD;
    &lt;li&gt;&#xD;
        The cost and complexity of having too many different implementation mechanisms to acquire and integrate.&#xD;
    &lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;p&gt;&#xD;
    The overall goal is always to have a simple, clean set of mechanisms that give conceptual integrity, simplicity, and&#xD;
    elegance to a large system.&#xD;
&lt;/p&gt;&#xD;
&lt;h3&gt;&#xD;
    Describing Design Mechanisms&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    As with analysis mechanisms, design mechanisms can be modeled using a collaboration, which may instantiate one or more&#xD;
    architectural or design patterns.&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p&gt;&#xD;
        &lt;strong&gt;Example: A persistence mechanism&lt;/strong&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;p&gt;&#xD;
        This example uses an instance of a pattern for RDBMS-based persistency drawn from &lt;a&#xD;
        href="http://java.sun.com/products/jdbc/index.html" target="_blank"&gt;&lt;u&gt;Java&amp;trade; Database Connectivity (JDBC)&lt;/u&gt;&lt;/a&gt;.&#xD;
        Although we present the design here, JDBC supplies actual code for some of the classes. Therefore, it is a short&#xD;
        step from what is presented here to an implementation mechanism.&#xD;
    &lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;&#xD;
    Figure 4, titled &lt;strong&gt;JDBC: Static view,&lt;/strong&gt; shows the classes (actually, the classifier roles) in the&#xD;
    collaboration.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 4. JDBC: Static View" height="382"&#xD;
    alt="Diagram of the figure titled Static View: JDBC shows the classes (actually, the classifier roles) in the collaboration. "&#xD;
     src="resources/jdbc1.gif" width="571" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;strong&gt;Figure 4. JDBC: Static view&lt;/strong&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    The yellow classes are the ones that were supplied. The others, in tan (&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;myDBClass&lt;/font&gt; class and so on), were bound by the designer to create the&#xD;
    mechanism.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    In a Java database class, a client will work with a &lt;b&gt;DBClass&lt;/b&gt; to read and write persistent data. &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; is responsible for accessing the JDBC database, using the&#xD;
    &lt;b&gt;DriverManager&lt;/b&gt; class. Once a database &lt;b&gt;connection&lt;/b&gt; is open, the &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; can then create SQL statements that will be sent to the underlying&#xD;
    RDBMS and executed using the &lt;b&gt;Statement&lt;/b&gt; class. &lt;font face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; class is&#xD;
    what communicates with the database. The result of the SQL query is returned in a &lt;b&gt;ResultSet&lt;/b&gt; object.&lt;span&#xD;
    style="mso-spacerun: yes"&gt;&amp;nbsp;&lt;/span&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    The &lt;b&gt;DBClass&lt;/b&gt; is responsible for making another class instance persistent. It understands the OO-to-RDBMS mapping&#xD;
    and can interface with the RDBMS. &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; flattens the object, writes it&#xD;
    to the RDBMS, and then reads the object data from the RDBMS and builds the object. Every class that is persistent has a&#xD;
    corresponding &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt;.&amp;nbsp;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    The &lt;b&gt;PersistentClassList&lt;/b&gt; is used to return a set of persistent objects as a result of a database query, for&#xD;
    example: &lt;font face="Courier New, Courier, mono"&gt;"DBClass.read()"&lt;/font&gt;.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    A series of dynamic views follow, in Figures 5 thorough 9, to show how the mechanism actually works.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 5. JDBC: Initialize" height="146" alt="Diagram of JDBC: Initialize" src="resources/jdbc2.gif"&#xD;
    width="285" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;b&gt;Figure5. JDBC: Initialize&lt;/b&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    Initialization must occur before any persistent class can be accessed.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    To initialize the connection to the database, the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; must load the&#xD;
    appropriate driver by calling the &lt;font face="Courier New, Courier, mono"&gt;DriverManager getConnection()&lt;/font&gt;&#xD;
    operation with a URL, user, and password.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    The operation &lt;font face="Courier New, Courier, mono"&gt;getConnection()&lt;/font&gt; attempts to establish a connection to the&#xD;
    given database URL. The driver manager attempts to select an appropriate driver from the set of registered JDBC&#xD;
    drivers.&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p&gt;&#xD;
        &lt;strong&gt;Parameters&lt;/strong&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;blockquote&gt;&#xD;
        &lt;p&gt;&#xD;
            &lt;b&gt;URL&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; A database URL in the form &lt;font&#xD;
            face="Courier New, Courier, mono"&gt;jdbc:subprotocol:subname&lt;/font&gt;. This URL is used to locate the actual&#xD;
            database server and is not Web-related, in this instance.&#xD;
        &lt;/p&gt;&#xD;
        &lt;p&gt;&#xD;
            &lt;b&gt;user&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; The database user who is making the connection.&#xD;
        &lt;/p&gt;&#xD;
        &lt;p&gt;&#xD;
            &lt;b&gt;pass&lt;/b&gt;&lt;strong&gt;:&lt;/strong&gt; The user's password&#xD;
        &lt;/p&gt;&#xD;
    &lt;/blockquote&gt;&#xD;
    &lt;p&gt;&#xD;
        &lt;strong&gt;Returns&lt;/strong&gt;&#xD;
    &lt;/p&gt;&#xD;
    &lt;blockquote&gt;&#xD;
        &lt;p&gt;&#xD;
            A connection to the URL.&#xD;
        &lt;/p&gt;&#xD;
    &lt;/blockquote&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 6. JDBC: Create" height="253" alt="Diagram of JDBC: Create" src="resources/jdbc3.gif" width="478" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;b&gt;Figure 6. JDBC: Create&lt;/b&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    To create a new class, the persistency client asks the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object to&#xD;
    create the new class. &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; creates a new instance of a class "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt;". &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt;&#xD;
    object then creates a new &lt;font face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; object using &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Connection class createStatement()&lt;/font&gt; operation. &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; object runs, and the data is added to the database.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 7. JDBC: Read" height="352" alt="Diagram of JDBC: Read" src="resources/jdbc4.gif" width="600" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;b&gt;Figure 7. JDBC: Read&lt;/b&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    To read a persistent class, the persistency client asks the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt;&#xD;
    object to read. &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object creates a new &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; object using &lt;font face="Courier New, Courier, mono"&gt;Connection&#xD;
    class createStatement()&lt;/font&gt; operation. The Statement is executed, and the data is returned in the &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;ResultSet&lt;/font&gt; object. &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt;&#xD;
    object then creates a new instance of the &lt;font face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt; class and&#xD;
    populates it with the retrieved data. The data is returned in a collection object, an instance of &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;PersistentClassList&lt;/font&gt; class.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    &lt;strong&gt;Note:&lt;/strong&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    The string passed to the &lt;font face="Courier New, Courier, mono"&gt;"executeQuery()"&lt;/font&gt; method is not necessarily&#xD;
    exactly the same string as the one passed into the method &lt;font face="Courier New, Courier, mono"&gt;"read()"&lt;/font&gt;.&#xD;
    &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object will build the SQL query to retrieve the persistent data&#xD;
    from the database, using the criteria passed into the method &lt;font face="Courier New, Courier, mono"&gt;"read()"&lt;/font&gt;.&#xD;
    This is because the client of the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object does not need to know&#xD;
    the internal structure of the database to create a valid query. This knowledge is encapsulated within the object &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;"DBClass"&lt;/font&gt;.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 8. JDBC: Update" height="255" alt="Diagram of JDBC: Update" src="resources/jdbc5.gif" width="473" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;b&gt;Figure 8. JDBC: Update&lt;/b&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    To update a class, the persistency client asks the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object to&#xD;
    update. &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object retrieves the data from the given object "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt;". It creates a new object "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt;" using the operation "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Connection class createStatement()&lt;/font&gt;". Once &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; object is built, the database is updated with the new data from the&#xD;
    class.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    &lt;strong&gt;Remember:&lt;/strong&gt; It is the job of &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object to flatten&#xD;
    the object &lt;font face="Courier New, Courier, mono"&gt;"PersistentClass"&lt;/font&gt;, and write it to the database. That is why&#xD;
    it must be retrieved from the given object "&lt;font face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt;" before&#xD;
    creating the SQL &lt;font face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt;.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    &lt;strong&gt;Note:&lt;/strong&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    In the above mechanism, the &lt;font face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt; must provide access routines&#xD;
    for all persistent data so that the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; can access them. This&#xD;
    provides external access to certain persistent attributes that would have been private otherwise. This is a price you&#xD;
    have to pay to pull the persistence knowledge out of the class that encapsulates the data.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;img title="Figure 9. JDBC: Delete" height="255" alt="Diagram of JDBC: Delete" src="resources/jdbc6.gif" width="473" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="center"&gt;&#xD;
    &lt;b&gt;Figure 9. JDBC: Delete&lt;/b&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    To delete a class, the persistency client asks the &lt;font face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object to&#xD;
    delete &lt;font face="Courier New, Courier, mono"&gt;PersistentClass&lt;/font&gt;. &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object creates a new object "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt;" using the operation "&lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Connection class createStatement()&lt;/font&gt;". &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;Statement&lt;/font&gt; object is executed and the data is removed from the database.&#xD;
&lt;/p&gt;&#xD;
&lt;p align="left"&gt;&#xD;
    In the actual implementation of this design, you would make some decisions about the mapping of the &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; object to the persistent classes, such as having one &lt;font&#xD;
    face="Courier New, Courier, mono"&gt;DBClass&lt;/font&gt; per persistent class and allocating them to appropriate packages.&#xD;
    These packages will depend on the supplied java.sql file (see &lt;a&#xD;
    href="http://java.sun.com/products/jdbc/index.jsp"&gt;JDBC: API Documentation&lt;/a&gt;) package that contains the supporting&#xD;
    classes &lt;font face="Courier New, Courier, mono"&gt;"DriverManager", "Connection", "Statement", "ResultSet"&lt;/font&gt;.&#xD;
&lt;/p&gt;</mainDescription>
</org.eclipse.epf.uma:ContentDescription>