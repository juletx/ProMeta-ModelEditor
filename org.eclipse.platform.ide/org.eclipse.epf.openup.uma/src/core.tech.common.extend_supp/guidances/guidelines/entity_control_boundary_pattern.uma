<?xml version="1.0" encoding="UTF-8"?><org.eclipse.epf.uma:ContentDescription xmlns:epf="http://www.eclipse.org/epf" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:xmi="http://www.omg.org/XMI" longPresentationName="finding_analysis_classes,_uF-QYEAhEdq_UJTvM1DM2Q" xmi:version="2.0" epf:version="1.5.1" xmi:id="-awaQ_2dwhGyKRoVKQ-esPQ" name="finding_analysis_classes,_uF-QYEAhEdq_UJTvM1DM2Q" guid="-awaQ_2dwhGyKRoVKQ-esPQ" changeDate="2008-09-04T12:21:52.000+0200" version="1.0.0">
  <mainDescription>&lt;p&gt;&#xD;
    When identifying the elements for a scenario of system behavior, you can align each participating element with one of&#xD;
    three key perspectives: &lt;b&gt;Entity&lt;/b&gt;, &lt;b&gt;Control&lt;/b&gt;, or &lt;b&gt;Boundary&lt;/b&gt;. Although specifics of languages, frameworks,&#xD;
    and heuristics of quality design will drive the final design, a first cut that covers required system behavior can&#xD;
    always be assembled with elements of these three perspectives.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    This pattern is similar to the Model View Controller pattern (described here [&lt;a class="elementLinkWithUserText"&#xD;
    href="./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html#BUS96"&#xD;
    guid="_9ToeIB83Edqsvps02rpOOg"&gt;BUS96&lt;/a&gt;] and here [&lt;a class="elementLinkWithUserText"&#xD;
    href="./../../../core.tech.common.base/guidances/supportingmaterials/references.tech_6CCF393.html#WIKP-MVC"&#xD;
    guid="_9ToeIB83Edqsvps02rpOOg"&gt;WIKP-MVC&lt;/a&gt;], among other places), but the Entity Control Boundary (ECB) pattern is not&#xD;
    solely appropriate for dealing with user interfaces, and it gives the controller a slightly different role to play.&#xD;
&lt;/p&gt;&#xD;
&lt;h4 align="left"&gt;&#xD;
    ECB&amp;nbsp;pattern example&#xD;
&lt;/h4&gt;&#xD;
&lt;p&gt;&#xD;
    &amp;nbsp;&lt;img alt="" src="resources/ebc_diagram.jpg" /&gt;&#xD;
&lt;/p&gt;&#xD;
&lt;h3&gt;&#xD;
    Entity elements&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    An entity is a long-lived, passive element that is responsible for some meaningful chunk of information. This is not to&#xD;
    say that entities are "data," while other design elements are "function." Entities perform behavior organized around&#xD;
    some cohesive amount of data.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    An example of an entity for a customer service application is a Customer entity that manages all information about a&#xD;
    customer. A design element for&amp;nbsp;this entity would include data about the customer, behavior to manage the data,&#xD;
    behavior to validate customer information&amp;nbsp;and to perform other business calculations, such as "Is this customer&#xD;
    allowed to purchase product X?"&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    The identification of the entities as part of this pattern can be done many times at different levels of abstraction&#xD;
    from the code, at different levels of granularity in size, and from the perspectives of different contexts. For&#xD;
    example, you could do an analysis pass on a scenario of creating a marketing campaign and identify the customer element&#xD;
    with various customer data elements, such as name and address, plus various required behaviors, such as the management&#xD;
    of the name and address data and the ability to rate the customer based on some algorithm (such an application of this&#xD;
    pattern would be abstract from code, coarse-grained, and have no specific context). Later, you could do a pass on the&#xD;
    same scenario applying an architectural mechanism for database access that breaks the address out as its own element,&#xD;
    moves the responsibility for storing and retrieving customers to a new control element, and identifies specific&#xD;
    database decisions, such as the use of primary keys in the entities. (Such an application of this pattern would be&#xD;
    closer to the code, finer-grained, and aligned with a database&amp;nbsp;context.)&#xD;
&lt;/p&gt;&#xD;
&lt;h3&gt;&#xD;
    Control elements&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    A control element manages the flow of interaction of the scenario. A control element could manage the end-to-end&#xD;
    behavior of a scenario or it could manage the interactions between a subset of the elements. Behavior and business&#xD;
    rules relating to the information relevant to the scenario should be assigned to the entities; the control elements are&#xD;
    responsible only for the flow of the scenario.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    CreateMarketingCampaign is an example of a control element for a customer service application. This design element&#xD;
    would&amp;nbsp;be responsive to certain front-end boundary elements and would collaborate with other entities,&#xD;
    control&amp;nbsp;elements, and back-end boundary elements to support the creation of a marketing campaign.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    As with the entity example here, there might be many passes over the identification of control elements. A first pass&#xD;
    might be an analysis pass that identifies one control element for a scenario, with behavior to make sure that the&#xD;
    design can support the flow of events. A&amp;nbsp;subsequent pass might find controllers to manage reusable collaborations&#xD;
    of low-level elements that will map to a specific code&amp;nbsp;unit to be written.&#xD;
&lt;/p&gt;&#xD;
&lt;h3&gt;&#xD;
    Boundary elements&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    A boundary element lies on the periphery of a system or subsystem, but within it. For any scenario being considered&#xD;
    either across the whole system or within some subsystem, some boundary elements will be "front end" elements that&#xD;
    accept input from outside of the area under design, and other elements will be "back end," managing communication to&#xD;
    supporting elements outside of the system or subsystem.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    Two examples of boundary elements for a customer service application might be a front end MarketingCampaignForm and a&#xD;
    back end BudgetSystem element. The MarketingCampaignForm would manage the exchange of information between a user and&#xD;
    the system, and the BudgetSystem would manage the exchange of information between the system and an external system&#xD;
    that manages budgets.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    If the system communicates with another system (where that system could be anything from software to hardware units&#xD;
    that the current system will use, such as printers, terminals, alarm devices, and sensors).&amp;nbsp; An analysis pass&#xD;
    could identify one boundary element for each external relevant to a scenario.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    Example:&#xD;
&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
    &lt;p&gt;&#xD;
        An automated teller machine (ATM) must communicate with the ATM network to ascertain whether a customer's bank&#xD;
        number and PIN are correct, and whether the customer has sufficient funds to withdrawal the requested amount. The&#xD;
        ATM network is an external system (from the perspective of the ATM); therefore, you would use a&#xD;
        &lt;strong&gt;boundary&lt;/strong&gt; class to represent it in a use-case analysis.&#xD;
    &lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;&#xD;
    Subsequently, these could be broken down into multiple boundary elements or small communities made up of collaborating&#xD;
    elements of all three stereotypes. If the interfaces with the system are simple and well-defined, a single class may be&#xD;
    sufficient to represent the external system. Often, however, these interfaces are too complex to be represented by&#xD;
    using a single class; they often require complex collaborations of many classes. Moreover, interfaces between systems&#xD;
    are often highly reusable across applications. As a result, in many cases, a component models the system interfaces&#xD;
    more appropriately.&amp;nbsp; The use of a component allows the interface to the external system to be defined and&#xD;
    stabilized, while leaving the design details of the system interface hidden as the system evolves.&#xD;
&lt;/p&gt;&#xD;
&lt;h3&gt;&#xD;
    Walking through the scenario&#xD;
&lt;/h3&gt;&#xD;
&lt;p&gt;&#xD;
    You can walk through a scenario initiated by something outside of the boundaries of the system or subsystem being&#xD;
    designed and distribute the responsibility to perform behavior supporting the scenario to the elements identified of&#xD;
    each type. The appropriate design element responsible for each action in the scenario will be as described in the&#xD;
    definition of each of the element types described here previously.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    In addition to identifying the behavior necessary to perform the scenario, the initiation of this behavior from design&#xD;
    element to design element identifies the necessary relationships. There are certain appropriate relations between the&#xD;
    participating elements. An element can communicate with other elements of the same kind. Control elements can&#xD;
    communicate with each of the other two kinds, but entities and boundary elements should not communicate directly.&#xD;
&lt;/p&gt;&#xD;
&lt;p&gt;&#xD;
    This table shows appropriate links between design elements.&#xD;
&lt;/p&gt;&#xD;
&lt;table cellspacing="2" cellpadding="2" width="400" summary="Appropriate Links" border="1"&gt;&#xD;
    &lt;tbody&gt;&#xD;
        &lt;tr&gt;&#xD;
            &lt;td&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;th scope="col"&gt;&#xD;
                &lt;center&gt;&#xD;
                    Entity&#xD;
                &lt;/center&gt;&#xD;
            &lt;/th&gt;&#xD;
            &lt;th scope="col"&gt;&#xD;
                &lt;center&gt;&#xD;
                    Boundary&#xD;
                &lt;/center&gt;&#xD;
            &lt;/th&gt;&#xD;
            &lt;th scope="col"&gt;&#xD;
                &lt;center&gt;&#xD;
                    Control&#xD;
                &lt;/center&gt;&#xD;
            &lt;/th&gt;&#xD;
        &lt;/tr&gt;&#xD;
        &lt;tr&gt;&#xD;
            &lt;th scope="row"&gt;&#xD;
                Entity&#xD;
            &lt;/th&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
        &lt;/tr&gt;&#xD;
        &lt;tr&gt;&#xD;
            &lt;th scope="row"&gt;&#xD;
                Boundary&#xD;
            &lt;/th&gt;&#xD;
            &lt;td&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
        &lt;/tr&gt;&#xD;
        &lt;tr&gt;&#xD;
            &lt;th scope="row"&gt;&#xD;
                Control&#xD;
            &lt;/th&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
            &lt;td&gt;&#xD;
                &lt;center&gt;&#xD;
                    X&#xD;
                &lt;/center&gt;&#xD;
            &lt;/td&gt;&#xD;
        &lt;/tr&gt;&#xD;
    &lt;/tbody&gt;&#xD;
&lt;/table&gt;&#xD;
&lt;p&gt;&#xD;
    By applying this pattern, you can put a robust design together that identifies the elements, behavior, and&#xD;
    relationships necessary to support a scenario.&#xD;
&lt;/p&gt;</mainDescription>
</org.eclipse.epf.uma:ContentDescription>