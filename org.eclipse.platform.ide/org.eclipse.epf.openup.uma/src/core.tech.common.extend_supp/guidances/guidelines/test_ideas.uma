<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="_y3rxsMM3EdmSIPI87WLu3g" name="test_ideas,_0jzlsMlgEdmt3adZL5Dmdw" guid="_y3rxsMM3EdmSIPI87WLu3g" changeDate="2006-09-29T18:37:59.000+0200" version="1.0.0" mainDescription="&lt;h3>&#xD;&#xA;    Introduction&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Test ideas are used to generate tests.&amp;nbsp;Test ideas can come from many different sources.&amp;nbsp;In general, they can&#xD;&#xA;    be derived in different ways depending on the given development domain, the kind of application being developed, and&#xD;&#xA;    the sophistication of the testers.&amp;nbsp;Although test ideas are derived in many different ways, there are some useful&#xD;&#xA;    categories for generating them.&amp;nbsp;This guideline will describe some of these categories as well as some general&#xD;&#xA;    heuristics for creating good test ideas.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Test Ideas and Functions&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Below are some test ideas to calculate the square root:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ol>&#xD;&#xA;    &lt;li>&#xD;&#xA;        A number that's barely less than zero as input&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Zero as the input&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Number that's a perfect square, like 4 or 16 (is the result exactly 2 or 4?)&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Print to a LaserJet IIIp&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Test with database full&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ol>&#xD;&#xA;&lt;p>&#xD;&#xA;    The first&amp;nbsp;3 test ideas validate input while the last 2 address environmental issues.&amp;nbsp; Even though these&#xD;&#xA;    statements are very incomplete they ensure that an idea is not forgotten.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Test Ideas and Boundaries&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Test ideas are often based on fault models.&amp;nbsp; Consider boundaries. It's safe to assume the square root function can&#xD;&#xA;    be implemented something like this:&lt;br />&#xD;&#xA;    &lt;!-- START NON-TRANSLATABLE -->&#xD;&#xA;    double sqrt(double x) {&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp; if (x &amp;lt; 0)&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // signal error&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ...&lt;br />&#xD;&#xA;    &lt;!-- END NON-TRANSLATABLE -->&#xD;&#xA;    It's also plausible that the &amp;lt; will be incorrectly typed as &amp;lt;=. People often make that kind of mistake, so it's&#xD;&#xA;    worth checking. The fault cannot be detected with X having the value 2, because both the incorrect expression (x&amp;lt;=0)&#xD;&#xA;    and the correct expression (x&amp;lt;0) will take the same branch of the if statement. Similarly, giving X the value -5&#xD;&#xA;    cannot find the fault. The only way to find it is to give X the value 0, which justifies the second test idea.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Test Idea and Methods&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Let's suppose you're designing tests for a method that searches for a string in a sequential collection. It can either&#xD;&#xA;    obey case or ignore case in its search, and it returns the index of the first match found or -1 if no match is&#xD;&#xA;    found.&lt;br />&#xD;&#xA;    int Collection.find(String string, Boolean ignoreCase);&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Here are some test ideas for this method, each of which could be implemented as a test.&amp;nbsp;&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ol>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Match found in the first position&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Match found in the last position&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        No match found&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Two or more matches found in the collection&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Case is ignored; match found, but it wouldn't match if case was obeyed&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Case is obeyed; an exact match is found&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Case is obeyed; a string that would have matched if case were ignored is skipped&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ol>&#xD;&#xA;&lt;p>&#xD;&#xA;    However, different test ideas can be combined into a single test; for example, the following test satisfies test ideas&#xD;&#xA;    2, 6, and 7:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;strong>Setup:&lt;/strong> Collection initialized to [&quot;dawn&quot;, &quot;Dawn&quot;]&lt;br />&#xD;&#xA;    &lt;strong>Invocation:&lt;/strong> Collection.find(&quot;Dawn&quot;, false)&lt;br />&#xD;&#xA;    &lt;strong>Expected result:&lt;/strong> Return value is 1 (it would be 0 if &quot;dawn&quot; were not skipped)&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Test Idea Simplicity and Complexity&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Making test ideas nonspecific makes them easier to combine.&lt;br />&#xD;&#xA;    Creating many several small tests that satisfy a few test ideas makes it simpler to:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &quot;Copy and Tweak&quot; the tests to meet other test idea&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Easy of debugging - if you have test that covers 2 test ideas then you know the fault is one or two area, but if&#xD;&#xA;        the test covers 7 test ideas you will spend more time debugging the issue.&amp;nbsp;&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    If the test ideas list were complete, with a test idea for every fault in the program, it wouldn't matter how you wrote&#xD;&#xA;    the tests. But the list is always missing some test ideas that could find bugs. Smaller more complex tests increase the&#xD;&#xA;    chance the test will satisfy a test idea that you didn't know you needed.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Complex Tests&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Sometimes when you're creating more complex tests, new test ideas come to mind. However, there are reasons for not&#xD;&#xA;    creating complex tests.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Complex test are more difficult to debug because they usually cover multiple test ideas&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Complex tests are more difficult to understand and maintain. The intent of the test is less obvious.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        Complex tests are more difficult to create.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Constructing a test that satisfies five test ideas often takes more time than constructing five tests that each&#xD;&#xA;    satisfies one. Moreover, it's easier to make mistakes - to think you're satisfying all five when you're only satisfying&#xD;&#xA;    four.&lt;br />&#xD;&#xA;    In practice, find a reasonable balance between complexity and simplicity.&lt;br />&#xD;&#xA;&lt;/p>" longPresentationName="test_ideas,_0jzlsMlgEdmt3adZL5Dmdw"/>
