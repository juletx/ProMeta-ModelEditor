<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-H6wteXNcAgxFYU3xQqceZw" name="new_guideline,_IuFgEIm-Ed2dvb7--2nAHw" guid="-H6wteXNcAgxFYU3xQqceZw" authors="Jerome Boyer" changeDate="2011-09-28T21:00:06.662+0200" version="7.5.0" mainDescription="&lt;p>&#xD;&#xA;    The goal of this &lt;a href=&quot;http://jcp.org/aboutJava/communityprocess/review/jsr094/index.html&quot;&#xD;&#xA;    target=&quot;_blank&quot;>specification&lt;/a> aims to make the client code for simple rule-based applications less dependent on&#xD;&#xA;    rule engine vendor-specific classes. The basic interactions with a rule engine are typically parsing the rules in scope&#xD;&#xA;    of a rule set, adding object references to one engine, firing the rules and getting results from the engine.&lt;br />&#xD;&#xA;    JSR94 defines a rule set as a &lt;em>rule execution set&lt;/em> which can be loaded from external resources like URIs, Input&#xD;&#xA;    streams, XML streams and readers. A rule execution set is a collection of rules. Another important JSR94 concept is the&#xD;&#xA;    &lt;em>rule session&lt;/em> which is a runtime connection between a client and a rule engine. A rule session is associated&#xD;&#xA;    with a single rule execution set, consumes rule engine resources and must be explicitly released when the client no&#xD;&#xA;    longer requires it. Session can be stateless or stateful. Stateless executes a rule execution set with a list of input&#xD;&#xA;    objects in one call. Stateful is designed to maintain a long time conversation between the client and the engine and&#xD;&#xA;    provides mechanism to assert / retract input object to the session.&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The client code may run on server layer like a servlet controller, in a service tier part of an EJB or POJO, or in a&#xD;&#xA;    standalone JSE JVM. The &lt;em>javax.rules&lt;/em> API divides interaction with rule engines into administrative and runtime&#xD;&#xA;    interactions. The basic operations supported by JSR-94 are:&lt;br />&#xD;&#xA;    • Acquiring a rule session for a registered rule execution set.&lt;br />&#xD;&#xA;    • Deploying and undeploying rulesets into a rule engine instance&lt;br />&#xD;&#xA;    • Querying simple metadata about a ruleset&lt;br />&#xD;&#xA;    • Executing a ruleset in either a stateful or stateless mode&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h5>&#xD;&#xA;    The client code for run time execution&#xD;&#xA;&lt;/h5>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    From the client point of view the interaction with a rule engine is done using the rule session. But the first part is&#xD;&#xA;    to get an instance of the rule engine implementation. The service provider manager helps to get a rule service provider&#xD;&#xA;    which in turn helps to get rule run time and rule administration implementations. Every specific implementation exposes&#xD;&#xA;    an uniquely identifier for the service provider URL.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    // Get the rule service provider from the provider manager&lt;br />&#xD;&#xA;    Class.forName(&quot;ilog.rules.bres.jsr94.IlrRuleServiceProvider&quot;);&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    RuleServiceProvider serviceProvider = RuleServiceProviderManager.getRuleServiceProvider(“ilog.rules.bres.jsr94”);&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    • For the reference implementation the URL is org.jsp.jsr94.ri.RuleServiceProvider&lt;br />&#xD;&#xA;    • For JRules the is ilog.rules.bres.jsr94.IlrRuleServiceProvider, and the service provider name is&#xD;&#xA;    ilog.rules.bres.jsr94&lt;br />&#xD;&#xA;    • For JBoss-drools the is org.drools.jsr94.rules.RuleServiceProviderImpl and the service provider name is&#xD;&#xA;    http://drools.org.&lt;br />&#xD;&#xA;    The code above is used for JSE deployment, as in JEE environment runtime clients should resolve the RuleRuntime and&#xD;&#xA;    RuleAdministrator services directly using JNDI lookup.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    Javax.naming.InitialContext initialContext = new InitialContext();&lt;br />&#xD;&#xA;    RuleRuntime ruleRuntime =&lt;br />&#xD;&#xA;    (RuleRuntime) PortableRemoveObject.narrow(&lt;br />&#xD;&#xA;    initialContext.lookup(&quot;org.jcp.jsr94.ri.RuleRuntime&quot;),RuleRuntime.class );&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In JSE we can use an inversion of control pattern and get those URL references from a properties file or a file&#xD;&#xA;    descriptor.&lt;br />&#xD;&#xA;    The next step is to get a rule engine run time.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    // Get a RuleRuntime and invoke the rule execution.&lt;br />&#xD;&#xA;    RuleRuntime ruleRuntime = serviceProvider.getRuleRuntime();&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    The RuleRuntime interface exposes the method to create a rule session given a previously registered RuleExecutionSet&#xD;&#xA;    URI. It is possible to execute the rule engine in stateless or stateful mode using different type of rule session. We&#xD;&#xA;    need to specify the rule execution set URI and the session type.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    StatelessRuleSession statelessRuleSession = (StatelessRuleSession) ruleRuntime.createRuleSession(ruleExecutionSetURI,&#xD;&#xA;    rulesessionProperties,RuleRuntime.STATELESS_SESSION_TYPE);&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The second parameter is optional and is used to add some additional properties to the session. In JRules it is used to&#xD;&#xA;    give the references to the rule set parameters and to specify if the RuleSession is a J2SE POJO rule session or a J2EE&#xD;&#xA;    POJO rule session:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    Map rulesessionProperties = new HashMap(); rulesessionProperties.put(&quot;loan&quot;, loan);&lt;br />&#xD;&#xA;    rulesessionProperties.put(&quot;borrower&quot;, borrower);&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    A stateless rules session exposes a stateless rule execution API to an underlying rules engine with two different&#xD;&#xA;    methods to call the execution of the rule:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    public java.util.List executeRules(java.util.List objects)&lt;br />&#xD;&#xA;    throws InvalidRuleSessionException,java.rmi.RemoteException&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    The list of objects set as parameters will be inserted in the engine's working memory. The list returned includes all&#xD;&#xA;    the objects created by the executed rules. The only things we can retrieve with JSR94 from an execution are the objects&#xD;&#xA;    in the working memory. The second API uses a filter of objects the client code can supply to select those objects that&#xD;&#xA;    should be returned from the rule engine.&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Filtering objects&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    To filter out objects from the list of returned objects from the rule execution call, the client code needs to provide&#xD;&#xA;    an implementation of the ObjectFilter interface. The implementing class receives callback methods that allow filtering&#xD;&#xA;    out objects as desired. Here is a simple filter class that removes any loan which does not have messages.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    public class MyObjectFilter implements ObjectFilter {&lt;br />&#xD;&#xA;    &lt;br />&#xD;&#xA;    @Override&lt;br />&#xD;&#xA;    public Object filter(Object obj) {&lt;br />&#xD;&#xA;    if (obj instanceof Loan) {&lt;br />&#xD;&#xA;    Loan loan = (Loan)obj;&lt;br />&#xD;&#xA;    if (loan.getMessages().size() != 0)&lt;br />&#xD;&#xA;    return obj;&lt;br />&#xD;&#xA;    }&lt;br />&#xD;&#xA;    return null;&lt;br />&#xD;&#xA;    }&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Get rule execution set meta data&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    RuleRuntime can also being used to get the list of URIs that currently have rule execution set registered with them&#xD;&#xA;    using the API List listURIs=ruleRuntime.getRegistrations();&lt;br />&#xD;&#xA;    The other object involved is the RuleExecutionSetMetadata interface which exposes metadata about a Rule Execution Set&#xD;&#xA;    to runtime clients of a RuleSession like the name, URI and description of the rule execution set.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    RuleExecutionSetMetadata metadata=statelessRuleSession&lt;br />&#xD;&#xA;    .getRuleExecutionSetMetadata();&lt;br />&#xD;&#xA;    metadata.getName();&lt;br />&#xD;&#xA;    metadata.getDescription();&lt;br />&#xD;&#xA;    metadata.getUri()&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Stateful session&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    Client code can use stateful session to conduct long running conversation with the engine, and control the working&#xD;&#xA;    memory with new facts. Input Objects can be progressively added to the StatefulRuleSession through the addObject&#xD;&#xA;    method. Output Objects can be progressively retrieved though the getObject method.&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    StatefulRuleSession statefulRuleSession= (StatefulRuleSession) getRuleRuntime()&lt;br />&#xD;&#xA;    .createRuleSession(ruleExecutionSetURI, getProperties(loan, borrower),RuleRuntime.STATEFUL_SESSION_TYPE);&lt;br />&#xD;&#xA;    //first call the normal execution&lt;br />&#xD;&#xA;    statefulRuleSession.executeRules();&lt;br />&#xD;&#xA;    Loan l2 = new Loan(250000,240,7.25);&lt;br />&#xD;&#xA;    Handle hdl=statefulRuleSession.addObject(l2);&lt;br />&#xD;&#xA;    statefulRuleSession.executeRules();&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    Objects that have been added to the StatefulRuleSession must be removed and updated using the removeObject and&#xD;&#xA;    updateObject methods. A client must test for the existence of an added Object using the containsObject method. The&#xD;&#xA;    removeObject, updateObject, and containsObject methods must all use a javax.rules.Handle implementation&amp;nbsp;instances&#xD;&#xA;    to refer to and identify Object instances. Handle are used to ensure that Object instances can be unambiguously&#xD;&#xA;    identified in the event of multiple class loaders being used or the StatefulRuleSession being serialized. The addObject&#xD;&#xA;    methods returns a Handle instance for an Object added to a StatefulRuleSession, so that it can be used in the remove&#xD;&#xA;    API for example.&lt;br />&#xD;&#xA;    In JRules Ruleset parameters and objects added to the RuleSession when it is created are uniquely identified by an&#xD;&#xA;    instance of the IlrRuleSessionHandle class.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    &lt;br />&#xD;&#xA;    Administrate rule execution set&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;br />&#xD;&#xA;    Administrative tasks supported by the API javax.rules.admin include instantiating the rule engine and loading rules. To&#xD;&#xA;    get the rule administrator we use the service provider such as: RuleAdministrator ruleAdministrator =&#xD;&#xA;    serviceProvider.getRuleAdministrator();&lt;br />&#xD;&#xA;    &lt;br />&#xD;&#xA;    The RuleAdministrator allows RuleExecutionSet instances to be registered against a URI for use from the runtime API, as&#xD;&#xA;    well as methods to retrieve a RuleExecutionSetProvider and a LocalRuleExecutionSetProvider implementation. The&#xD;&#xA;    RuleExecutionSetProvider interface defines methods to create a RuleExecutionSet from a number of Serializable sources&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    LocalRuleExecutionSetProvider ruleExecutionSetProvider =&#xD;&#xA;    ruleAdministrator.getLocalRuleExecutionSetProvider(null);&lt;br />&#xD;&#xA;    RuleExecutionSet ruleSet = ruleExecutionSetProvider.createRuleExecutionSet( inputStream, null );&lt;br />&#xD;&#xA;    ruleAdministrator.registerRuleExecutionSet( ruleSet.getName(),ruleSet,null );&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The local rule execution set provider sends a local execution set to a remote engine using serialization and&#xD;&#xA;    marshaling. The API get(Local)RuleExecutionSetProvider takes an argument of type Map, which is documented as&#xD;&#xA;    &quot;additional properties&quot; and used for setting the JNDI properties. The source for the rule can come from&#xD;&#xA;    non-Serializable resources, such as binary InputStreams or character-based Readers. Registering the execution set to a&#xD;&#xA;    URI helps to create session to an execution set. The rules registered using the rules admin API are the only rules&#xD;&#xA;    accessible to the runtime clients.&lt;br />&#xD;&#xA;    The following code gets the name and description of the execution set deployed:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    ruleSet.getDescription();&lt;br />&#xD;&#xA;    ruleSet.getName();&lt;br />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    getName() in the case of JRules Rule Execution server deployment returns the rule set path. From the rules set we can&#xD;&#xA;    get all the rules in a list and then for each rule its name and description.&lt;br />&#xD;&#xA;    Rule.getName()returns in the case of JRules a string which specify the language name and the name space for this rule,&#xD;&#xA;    like for example “IRL/validation/maximum_amount-brl.irl”. The rule.getDescription() returns the rule in the language of&#xD;&#xA;    the rule engine vendor. For JRules it is the Ilog rule language such as:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p class=&quot;codeSample&quot;>&#xD;&#xA;    &lt;br />&#xD;&#xA;    package validation {&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp; rule maximum_amount {&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; property status = &quot;new&quot;;&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; when {&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;miniloan.Loan() from loan;&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; evaluate (loan.amount &amp;gt; 1000000);&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; } then {&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; loan.addToMessages(&quot;The loan cannot exceed&#xD;&#xA;    1,000,000&quot;);&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; loan.reject();&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br />&#xD;&#xA;    &amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br />&#xD;&#xA;    }&lt;br />&#xD;&#xA;    &lt;br />&#xD;&#xA;    &lt;br />&#xD;&#xA;    &amp;nbsp;&#xD;&#xA;&lt;/p>" longPresentationName="new_guideline,_IuFgEIm-Ed2dvb7--2nAHw"/>
