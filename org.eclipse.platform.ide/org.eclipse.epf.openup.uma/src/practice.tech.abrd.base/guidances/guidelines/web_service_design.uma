<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-z4b7YSb0hoz7fKqCWsc8uQ" name="new_guideline,_YRiuIItDEd2gksNyFVJN4g" guid="-z4b7YSb0hoz7fKqCWsc8uQ" changeDate="2008-09-25T10:49:34.000+0200" version="7.5.1" mainDescription="&lt;p>&#xA;    W3C defines web service as: &quot;A Web service is a software application identified by a URI, whose interfaces and binding&#xA;    are capable of being defined, described, and discovered by XML artifacts, and supports direct interactions with other&#xA;    software applications using XML-based messages via Internet-based protocols.&quot;&#xA;&lt;/p>&#xA;&lt;p>&#xA;    In software architecture literature It is agreed that the XML syntax to define the web service is WSDL.&#xA;&lt;/p>&#xA;&lt;h3>&#xA;    Three Approaches&#xA;&lt;/h3>&#xA;&lt;p>&#xA;    From a methodology point of view there are three possible approaches to design a web service:&#xA;&lt;/p>&#xA;&lt;ul>&#xA;    &lt;li>&#xA;        &lt;em>top-down&lt;/em>: The architect&amp;nbsp;first defines the Web service interface using WSDL and XML Schema (XSD)&#xA;        constructs, then generates implementation code for the service.&#xA;    &lt;/li>&#xA;    &lt;li>&#xA;        &lt;em>bottom-up&lt;/em>: from the developer environment like eclipse, we can create a web service and wsdl from an&#xA;        existing java code. The JAX-WS specification&amp;nbsp;defines annotations to put in the code to&amp;nbsp;define the&#xA;        service.&amp;nbsp;&#xA;    &lt;/li>&#xA;    &lt;li>&#xA;        &lt;em>meet in the middle:&lt;/em> combines the two approached above, but involves the development of code to manage the&#xA;        new interface as generated by the WSDL and the old API from the existing function.&#xA;    &lt;/li>&#xA;&lt;/ul>&#xA;&lt;p>&#xA;    The bottom-up approach as the advantage to quickly expose web service, and also permit to test within a java&#xA;    environment the implementation of the service. But this approach leads to have incompatible type definitions and so&#xA;    have multiple definitions for the same semantic.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    There is a common acceptance among software architects to use a top-down or meet in the middle approach, and define the&#xA;    common interface within the portType declaration of WSDL. The XML Schema specification defines a broader range of&#xA;    constructs for describing message structures than Java. Some of these include choices, derivation by restriction,&#xA;    annotation. Therefore, it is better to define your interface using WSDL and XSD, and generate skeletal Java code.&#xA;&lt;/p>&#xA;&lt;h3>&#xA;    Service Definition&#xA;&lt;/h3>&#xA;&lt;p>&#xA;    A service interface should generally contain more than one operation. Operations defined as part of a single service&#xA;    interface should be semantically related. Business transactions related to the same data as for example a claim are&#xA;    mapped to operations within the same interface: ProcessClaim. Having one interface per business function may lead to&#xA;    have a huge amount of service interfaces. Service proliferation, in turn, results in service governance problems,&#xA;    making it harder to pursue effective code reuse.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    if for example the data are coming from different physical systems, we could map the access to those different data&#xA;    sources with technical interfaces, and aggregate these interfaces into a single business interface.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    The signature of each operation can support different set of approaches: synchronous/ asynchronous, stateless/stateful,&#xA;    header based or carrying payload, use of faults or not.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    Asynchronous design means that once the client sent its message&amp;nbsp;it does not know if the message was successfully&#xA;    delivered or not, and if the service was able to process it. This is a one-way operation. It may be a good&#xA;    implementation for a Event Driven Architecture, leveraging an ESB for message reliability and delivery.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    Synchronous involves request-response operation. The client is blocked until it gets the response or a fault. Faults&#xA;    convey error information about failures that occur during the service invocation. Online application should leverage a&#xA;    synchronous definition of the service to ensure someone is taking care of the errors.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    When designing a new service, do not mix synchronous and asynchronous invocation semantics in a single WSDL port type.&#xA;    If it is advantageous to support both semantics, define separate interfaces for synchronous and asynchronous&#xA;    invocations.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    An important design consideration on the operation response message. It has to include some business semantic so that&#xA;    the client caller can do something in case of failure, like for example asynchronously ping the service for new&#xA;    response.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    Exchanges between services can be stateful or stateless in nature. A stateful, or conversational, exchange between&#xA;    services occurs when the service provider retains knowledge of data that has been exchanged between the service&#xA;    consumer and the service provider during preceding operation invocations. Stateless interfaces are considered superior&#xA;    in the context of building an SOA. A stateless interface can be readily reused by many service consumer applications&#xA;    that are free to manage state in the manner best suited to each application.&#xA;&lt;/p>&#xA;&lt;p>&#xA;    The request messages contain data that will be used by the service to perform the business logic of the operation.&#xA;    These messages can also contain data (ins SOAP user-defined headers for example)&amp;nbsp;that are more pertinent to&#xA;    system-level processing associated with the transaction. Such data can include service consumer&#xA;    identifier,&amp;nbsp;service producer version number (play old - new service), time stamps,...&#xA;&lt;/p>" longPresentationName="new_guideline,_YRiuIItDEd2gksNyFVJN4g"/>
