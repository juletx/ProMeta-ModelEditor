<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-1xE2ZW3MjNAJ7jkaZNbkww" name="visual_modeling,_1fM3AC9_EduW5uTjiIcspQ" guid="-1xE2ZW3MjNAJ7jkaZNbkww" changeDate="2006-11-21T20:21:26.000+0100" version="1.0.0" mainDescription="&lt;h3>&#xD;&#xA;    Introduction&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Using visual modeling techniques to design software can help break down complex problems into a series of smaller,&#xD;&#xA;    easier to manage tasks. Sharing pictures rather than written documents or source code also helps the understanding and&#xD;&#xA;    communication of difficult concepts. Adopting standard modeling notations such as the UML increases this capability by&#xD;&#xA;    helping to make diagrams precise and unambiguous.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The degree of formality used when producing and disseminating models should vary according to your needs. Small,&#xD;&#xA;    collaborative teams modeling around whiteboards and capturing the results on a sheet of paper or with digital cameras&#xD;&#xA;    can yield good results. This can also help the team focus on producing software with the help of models; rather than&#xD;&#xA;    becoming sidetracked into over-engineering both the models and the solution. Modeling tools provide additional value to&#xD;&#xA;    projects, especially for more complex systems. Their specifics of use are outside the scope of this guideline, however.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    This guideline does not describe a formal sequential progression through prescriptive design steps. Whether some or all&#xD;&#xA;    of these techniques are needed, or how long is spent on them will vary depending on real-world issues such as the&#xD;&#xA;    complexity of the requirements; the experience of the designer; and the way the team works.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    This guideline uses a simplified scenario (Login) to help keep the focus on understanding the techniques rather than&#xD;&#xA;    the specific requirements. In the real-world, it is doubtful that much time would be spent modeling a simple problem.&#xD;&#xA;    Here is the use case diagram, for reference;&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;142&quot; alt=&quot;User Login Use Case Model&quot; src=&quot;resources/user_login_ucm.jpg&quot; width=&quot;472&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Identify elements&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Render the identified design elements as classes in a UML diagram.&amp;nbsp; Apply appropriate stereotypes and optionally&#xD;&#xA;    render the class using an icon specific to the stereotype to characterize the intent of the class in the design.&amp;nbsp;&#xD;&#xA;    Name and briefly describe the classes in a few sentences. Do not spend too much time working on associations, as these&#xD;&#xA;    will be developed through working on collaborations in the next step.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Classes can be drawn as a basic UML rectangle or with a specific symbol associated with a particular stereotype.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The resulting class diagram should be conceptually similar to this one:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;228&quot; alt=&quot;Identify Elements - Initial Class Model&quot; src=&quot;resources/identify_elements_bce.jpg&quot;&#xD;&#xA;    width=&quot;290&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    For this example, the &lt;a class=&quot;elementLink&quot;&#xD;&#xA;    href=&quot;./../../../core.tech.common.extend_supp/guidances/guidelines/entity_control_boundary_pattern_C4047897.html&quot;&#xD;&#xA;    guid=&quot;_uF-QYEAhEdq_UJTvM1DM2Q&quot;>Entity-Control-Boundary Pattern&lt;/a> has been used to derive two classes (LoginUI and&#xD;&#xA;    LoginController). In addition, two design elements already identified in the architecture (SecuritySystemInterface and&#xD;&#xA;    User) have also been incorporated.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Determine how elements collaborate to realize the scenario&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    When determining collaboration, two kinds of diagrams are useful.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ul>&#xD;&#xA;    &lt;li>&#xD;&#xA;        A dynamic object diagram, showing how the design elements collaborate to realize the requirements.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        A static class diagram, showing the classes involved in realizing the requirements.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ul>&#xD;&#xA;&lt;p>&#xD;&#xA;    Remember to also update any other impacted diagrams as appropriate, based on modifications or additions to the design.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Create a number of dynamic object diagrams that walk through how a set of objects collaborate to perform the behavior&#xD;&#xA;    of the scenarios.&amp;nbsp; Even if just one scenario is being designed, this might take multiple diagrams to render it in&#xD;&#xA;    smaller, understandable chunks or from multiple contexts.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img style=&quot;WIDTH: 776px; HEIGHT: 355px&quot; height=&quot;355&quot; alt=&quot;User Login Sequence Diagram&quot;&#xD;&#xA;    src=&quot;resources/user_login_seq.jpg&quot; width=&quot;776&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    The above sequence diagram shows the user credentials being passed through to the security system for authentication.&#xD;&#xA;    Steps in the use case scenario are transformed into messages between the participating objects. The messages in this&#xD;&#xA;    example are not yet fully formed (there are no parameters or return values), so they are prefixed with &quot;//&quot; to show&#xD;&#xA;    that more work is needed.&amp;nbsp; A sequence diagram was used in this example, but a communication diagram could have&#xD;&#xA;    been used.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    It&amp;nbsp;can be&amp;nbsp;useful to create one or more static class diagrams that show the classes in the design that support&#xD;&#xA;    the realization.&amp;nbsp; These class diagrams are often called View of Participating Classes diagrams, they provide a&#xD;&#xA;    focused view on the overall design by only showing the classes, relationships, operations, and attributes relevant to&#xD;&#xA;    the collaboration.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;469&quot; alt=&quot;Login VOPC&quot; src=&quot;resources/login_vopc.jpg&quot; width=&quot;448&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    This diagram shows the operations and relationships that were identified by drawing the sequence diagram. The&#xD;&#xA;    relationships in this example&amp;nbsp;have not been refined yet, so they are just shown as simple associations. Remember&#xD;&#xA;    to examine the diagram to verify that the design can support the behavior in the sequence diagram.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Working at this level of detail in the model during the early stages of design can be helpful. It keeps the diagrams&#xD;&#xA;    relatively simple and easy to understand. It makes them easier to draw in a workshop and easier to change during&#xD;&#xA;    discussion. It is often easier to add the detail once there is agreement on the fundamentals.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Refine design decisions&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    Once the fundamentals of the design are relatively stable, you can begin to add detail to the design. Some of this can&#xD;&#xA;    be performed in code or in the model. If modeling is chosen, then refine attributes, responsibilities and&#xD;&#xA;    relationships.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Describe responsibilities&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    Class responsibilities are either actions to be performed by an object or knowledge maintained and provided to other&#xD;&#xA;    objects. Each class will typically have several responsibilities; each responsibility will evolve into one or more&#xD;&#xA;    operations during design.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Responsibilities are derived from messages on interaction diagrams or from non-functional requirements that a class has&#xD;&#xA;    to support. Document a responsibility by giving it a name, and optionally a brief description (what it does).&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    These operations can be left as self-evident from their context, they can be given textual descriptions of the&#xD;&#xA;    algorithm required to perform the behavior, or they could spawn off another whole pass of this technique where a set of&#xD;&#xA;    classes that collaborate together to perform the internals of the operation are identified, etc.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Describe attributes and associations&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    A class may have to store simple data information, like: string, integer, and the like. For such simple type of&#xD;&#xA;    information, attributes are defined for classes. For a more complex or &quot;behavioral&quot; attribute, consider creating an&#xD;&#xA;    extra class and establish an association to it.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    To perform their responsibilities, classes may depend on other classes to supply needed behavior. These other classes&#xD;&#xA;    might be ones already identified in this design session, they might be existing classes pulled from the architecture,&#xD;&#xA;    or the need for new classes might be conceived. Associations in a class diagram can be used to represent inter-class&#xD;&#xA;    relationships.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;439&quot; alt=&quot;Login VOPC (Refined)&quot; src=&quot;resources/login_vopc_refined.jpg&quot; width=&quot;557&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    This diagram shows a number of refinements. The LoginUI class has been replaced by LoginForm. The User class has been&#xD;&#xA;    renamed UserCredentials and is created by the LoginForm class rather than LoginController. It is then used as a&#xD;&#xA;    parameter for subsequent messages rather than passing the individual attributes. The SecuritySystemInterface class has&#xD;&#xA;    been refined into two elements, ISystemSecurity, which provides a simple façade for interaction with the rests of the&#xD;&#xA;    design; and SecuritySystemProxy, which handles interaction with the external security system.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Design internals&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    The classes in the design are likely to need to be distributed amongst different packages and subsystems or components.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;304&quot; alt=&quot;User Login - Design Packages&quot; src=&quot;resources/dv_packaging.jpg&quot; width=&quot;571&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    In this example, the LoginForm, LoginController and UserCredentials elements have been placed in a package called&#xD;&#xA;    LocalSecurity. The SecuritySystemProxy is a part of a subsystem called SecuritySystemAdapter which realizes the&#xD;&#xA;    ISecuritySystem interface. The SecuritySystemAdapter wraps the legacy SecuritySystem, expressed here as a component&#xD;&#xA;    offering a validateUser interface.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    Each of these packaged elements can be distributed amongst the team for further development work.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h3>&#xD;&#xA;    Conclusion&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    This guideline walked through the techniques in a concrete manner started with a scenario of a use case through to&#xD;&#xA;    distributing the classes identified into a set of packages. This example demonstrates a technique for designing&#xD;&#xA;    visually, but it should be considered as just one conceptual pass of design.&amp;nbsp; One could as easily apply this&#xD;&#xA;    technique when defining the internals of how the SecuritySystemProxy class will collaborate with a set of classes to&#xD;&#xA;    validate the credentials.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    When applying this guideline, work in small chunks and keep in mind the goal of delivering software to the users that&#xD;&#xA;    provides value. To deliver high-quality software requires consideration of how the pieces will work together to deliver&#xD;&#xA;    that value. But as soon as key decisions have been made and the decisions have been communicated to the appropriate&#xD;&#xA;    team members, the team should move on to implementing the source code to verify the design and deliver the value.&#xD;&#xA;&lt;/p>" longPresentationName="visual_modeling,_1fM3AC9_EduW5uTjiIcspQ"/>
