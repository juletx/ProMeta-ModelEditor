<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmi:id="-mItcFA1WMTAyJvkqMrXuMQ" name="new_guideline,_5s_DUJ03EdyQ3oTO93enUw" guid="-mItcFA1WMTAyJvkqMrXuMQ" changeDate="2008-10-14T19:03:34.000+0200" version="7.2.0" mainDescription="&lt;h3>&#xD;&#xA;    Introduction&#xD;&#xA;&lt;/h3>&#xD;&#xA;&lt;p>&#xD;&#xA;    With Test Driven Development (TDD) you do detailed design in a just-in-time (JIT) manner via writing a single test&#xD;&#xA;    before writing just enough production code to fulfill that test. When you have new functionality to add to your system,&#xD;&#xA;    perform the following steps:&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ol>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Quickly add a developer test&lt;/strong>. You need just enough implementation code to fail.&amp;nbsp; For example,&#xD;&#xA;        a new method about to be added to a class could be created that just throws a fatal exception.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Run your tests&lt;/strong>. You will typically run the complete test suite, although for sake of speed you may&#xD;&#xA;        decide to run only a subset. The goal is to ensure that the new test does in fact fail.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Update your production code&lt;/strong>. The goal is to add just enough functionality so that&amp;nbsp;the code&#xD;&#xA;        passes the new test.&amp;nbsp;&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Run your test suite again&lt;/strong>. If the tests fail you need to update your functional code and retest.&#xD;&#xA;        Once the tests pass, start over.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ol>&lt;br />&#xD;&#xA;&lt;p>&#xD;&#xA;    &lt;img height=&quot;600&quot; alt=&quot;Test First Design Flow&quot; src=&quot;resources/test_first_design.jpg&quot; width=&quot;294&quot; />&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;h4>&#xD;&#xA;    Why TDD?&#xD;&#xA;&lt;/h4>&#xD;&#xA;&lt;p>&#xD;&#xA;    A significant advantage of TDD is that it enables you to take small steps when writing software, which is not only&#xD;&#xA;    safer it is also far more productive than writing code in large steps. For example, assume you add some new functional&#xD;&#xA;    code, compile, and test it. Chances are pretty good that your tests will be broken by defects that exist in the new&#xD;&#xA;    code. It is much easier to find, and then fix, those defects if you've written five new lines of code than fifty lines.&#xD;&#xA;    The implication is that the faster your compiler and regression test suite, the more attractive it is to proceed in&#xD;&#xA;    smaller and smaller steps.&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;p>&#xD;&#xA;    There are other common testing strategies (listed here in order of effectiveness).&#xD;&#xA;&lt;/p>&#xD;&#xA;&lt;ol>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Write several tests first&lt;/strong>. This is a variant of TDD where you write more than one test before&#xD;&#xA;        writing just enough production code to fulfill those tests. The advantage is that you don't need to build your&#xD;&#xA;        system as often, potentially saving time. It has the disadvantage that you will write more production code at once,&#xD;&#xA;        increasing the difficulty of finding the cause of new bugs.&#xD;&#xA;    &lt;/li>&#xD;&#xA;    &lt;li>&#xD;&#xA;        &lt;strong>Test after the fact&lt;/strong>. With this approach you write some production code then you write enough&#xD;&#xA;        testing code to validate it. This has the advantage that you're at least still validating the code but has the&#xD;&#xA;        disadvantage that you lose the design benefit inherent in writing the testing code first.&#xD;&#xA;    &lt;/li>&#xD;&#xA;&lt;/ol>&#xD;&#xA;&lt;p>&#xD;&#xA;    An underlying assumption of TFD is that a unit-testing framework is available. Agile software developers often use the&#xD;&#xA;    xUnit family of open source tools, such as &lt;a href=&quot;http://www.junit.org/&quot;>&lt;strong>&lt;u>&lt;font&#xD;&#xA;    color=&quot;#0000ff&quot;>JUnit&lt;/font>&lt;/u>&lt;/strong>&lt;/a> or &lt;a href=&quot;http://www.vbunit.org/&quot;>&lt;strong>&lt;u>&lt;font&#xD;&#xA;    color=&quot;#0000ff&quot;>VBUnit&lt;/font>&lt;/u>&lt;/strong>&lt;/a>, although commercial tools are also viable options.&#xD;&#xA;&lt;/p>" longPresentationName="new_guideline,_5s_DUJ03EdyQ3oTO93enUw"/>
